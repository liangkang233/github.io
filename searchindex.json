{"categories":[{"title":"Core","uri":"https://liangkang233.github.io/categories/core/"},{"title":"Win10","uri":"https://liangkang233.github.io/categories/win10/"},{"title":"学习","uri":"https://liangkang233.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"title":"工具","uri":"https://liangkang233.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"title":"杂谈","uri":"https://liangkang233.github.io/categories/%E6%9D%82%E8%B0%88/"}],"posts":[{"content":" 笔记实时更新中。。\n Core、Emane 介绍 官方文档\n一句话概括: CORE侧重于模拟如网络层传输层、会话层和应用层，提供了用户构建虚拟网络的图形用户界面；在一台或多台计符机上进行网络模拟的工具，实时运行的模拟。这些模拟的网络可以实时连接到物理网络和路由器，可以在使用相对廉价的硬件的前提下，保证在模拟网络上运行实时的应用程序的真实性。\nEMANE主要针对物理层和数据链路层工作，为模拟链路层和物理层的无线网络提供了必需的可插拔框架。关于网络层路由协议选用OSPF MDR协议。\nCore Core源码\n通用开放式研究仿真器（Common Open Research Emulator）是一种构建虚拟网络的工具。作为模拟器，CORE 构建了实时运行的真实计算机网络的表示，而不是使用抽象模型的模拟。实时运行的仿真可以连接到物理网络和路由器。它提供了运行真实应用程序和协议的环境，利用了 Linux 操作系统提供的工具。\nCORE 通常用于网络和协议研究、演示、应用程序和平台测试、评估网络场景、安全研究以及增加物理测试网络的规模。\n   主题 描述 总结或翻译     Architecture 体系结构概述，介绍如何使用Python、gRPC直接控制Core 架构   Installation CORE的安装方法及要求 环境搭建   GUI 如何使用GUI 界面教程   Node Types CORE支持的节点类型概述 节点类型   (BETA) Python GUI 如何使用基于BETA Python的GUI    Python API 介绍如何使用Python直接控制Core(架构部分解析) Python API   gRPC API 介绍如何使用gRPC控制Core(架构部分细说) gRPC API   Distributed 在多个服务器上运行CORE的分布式细节 分布式   CTRLNET 如何控制网络从主机与节点通信 控制网络   Services 概述所提供的服务并创建自定义服务 服务   Core Emane CORE中运行和使用EMANE的高级主题和示例 Emane   Performance 使用CORE时的性能说明 Core 性能分析   Developers Guide 概述如何对CORE开发做出贡献 Core 开发相关     Core 常见问题    基础内容学习   TLV编码格式详解\n  了解 gRPC协议\n  什么是GRE隧道\n  OSPF MDR OSPF即开放最短路径优先(Open Shortest Path First)是为有线网络设计的标准路由协议。\n每个自治系统AS（Autonomous System）内部的路由选路协议，位于网络层。\nOSPF MDR即OSPF指定路由器移动自组网协议（OSPF MANET Designated Routers）也是美国海军研究实验室(NRL)开发，其源码在这可以找到。Quagga 中OSPFv3的OSPF MDR是依照移动自组织网络(MANETs: Mobile Ad Hoc Networks)中有效路由的 RFC 5614 (OSPF MDR), RFC 5243 (OSPF Database Exchange Optimization), 和 RFC 5838 (OSPFv3 Address Families)来实现的。\n该软件基于开源的Quagga路由套件，最初由Richard Ogier和波音幻影工程公司开发，现在由NRL的移动路由项目维护。\n  Linux基础网络设备详解：Core的链路实现就是依赖这些虚拟网络设备，利用Linux命名空间特性创建各个独立的虚拟节点。\n  Core 开发相关 源码概述 由于历史原因，CORE源代码由几种不同的编程语言组成。目前的开发重点是Python模块和守护进程。下面是源目录的简要描述。(netns = network nodes)\n   目录 描述     daemon 处理接收API调用和创建容器的Python CORE daemon（守护进程）代码   docs 托管在GitHub上的使用文档   gui Tcl/Tk GUI   man 为各种CORE命令行实用程序创建手册页的模板文件   netns 用于创建CORE容器的C程序    其切换开发版本分支\ngit clone https://github.com/coreemu/core.git cd core git checkout develop  安装开发环境 此命令将自动安装系统依赖项、克隆和构建 OSPF-MDR, 搭建CORE, 设置CORE poetry 环境, 然后安装 pre-commit hooks.您可以参考install docs来了解不同发行版的相关问题。\n./install -d  其中pre-commit帮助自动运行工具检查修改的代码。每次提交时，都会运行python实用程序来检查代码的有效性，可能会失败并退出提交。这些更改目前是作为当前CI的一部分强制执行的，因此添加更改并再次提交。\n运行core 您现在可以像平常一样运行core，或者利用一些调用任务来方便地运行测试等。\n# run core-daemon sudo core-daemon # run python gui core-pygui # run tcl gui core-gui # run mocked 单元测试 cd \u0026lt;CORE_REPO\u0026gt; inv test-mock  容器命令 Linux namespace containers通常使用Linux容器工具或lxc-tools包进行管理。lxc-tools网站可在这里http://lxc.sourceforge.net/获得更多信息。CORE不使用这些管理core实用工具(utilities)，core自己实现了一组用于实例化和配置网络名称空间容器的工具。这些工具大体分为：\n  vnoded (Virtual nodes daemon )\nvnoded daemon是用于创建新名称空间的程序，并在控制通道上侦听可能实例化其他进程的命令。这个守护进程在容器中作为PID 1运行。它由CORE守护进程自动启动。控制通道是UNIX域套接字，通常命名为/tmp/pycore。对于运行在CORE会话23098上的节点3，例如:23098/n3。创建一个新的命名空间需要Root特权。\n  vcmd (Virtual cmd )\nvcmd程序用于连接Linux网络命名空间中的vnoded，用于运行命名空间容器中的命令。CORE守护进程使用相同的通道设置节点并在其中运行进程。这个程序有两个必需的参数，控制通道名和要在命名空间中运行的命令行。该命令不需要以root权限运行。\n当你在运行模拟中双击一个节点时，CORE会使用如下命令打开该节点的shell窗口:\ngnome-terminal -e vcmd -c /tmp/pycore.50160/n1 -- bash  类似地，IPv4路由观察者小部件将运行一个命令来显示路由表，使用如下命令:\nvcmd -c /tmp/pycore.50160/n1 -- /sbin/ip -4 ro    core-cleanup 脚本\n提供了一个名为 core-cleanup 的脚本来清理任何正在运行的CORE仿真。它将试图杀死任何剩余的vnoded进程，杀死任何EMANE进程，删除 :file:/tmp/pycore.* 会话目录。删除任何bridge或ebtables规则。使用*-d*选项，它也将杀死任何正在运行的CORE守护进程。\n  netns 命令\nCORE不直接使用netns命令。此实用程序可用于在新的网络名称空间中运行命令，以进行测试。它不会打开一个控制通道来接收进一步的命令。\n  其他常用命令\n# 查看Linux网桥配置 ip link show type bridge # 查看用于应用链接效果的netem规则 tc qdisc show # 查看使无线局域网工作的规则 ebtables -L    Core 性能分析 关于CORE性能的首要问题通常是它能处理多少个节点?答案取决于几个因素:\n   因素 性能影响     硬件 计算机中处理器的数量和速度、可用的处理器缓存、RAM内存和前端总线速度可能会极大地影响整体性能。   系统版本 Linux的发行和所使用的特定内核版本将影响整体性能。   活动进程 所有节点共享相同的CPU资源，因此如果一个或多个节点执行CPU密集型任务，整体性能将受到影响。   网络流量 在虚拟网络中发送的数据包越多，CPU使用率就越高。   GUI使用 定期运行的小部件、移动场景和其他GUI交互通常会消耗模拟所需的CPU周期。    在典型的单cpu 3.0GHz Xeon服务器上，2GB RAM运行Linux，我们发现运行30-75个节点运行OSPFv2和OSPFv3路由是合理的。在这个硬件上，CORE可以实例化100个或更多的节点，但是在这一点上，每个节点在做什么就变得至关重要了。\n因为这个软件主要是一个网络模拟器，所以更合适的问题是它能处理多少网络流量?在上面描述的3.0GHz服务器上，运行Linux，大约每秒可以通过系统推送30万个包。跳数和报文大小不那么重要。限制因素是操作系统需要处理数据包的次数。300,000pps表示系统作为一个整体需要处理一个数据包的次数。随着更多的网络跳数的增加，上下文切换的数量会增加，并且会降低整个网络路径上的吞吐量。\n注意: 问题关键在于是能跑多少流量? 而不是多少节点\n有关CORE性能的更详细研究，请参阅以下出版物:\n J. Ahrenholz, T. Goff, and B. Adamson, Integration of the CORE and EMANE Network Emulators, Proceedings of the IEEE Military Communications Conference 2011, November 2011. Ahrenholz, J., Comparison of CORE Network Emulation Platforms, Proceedings of the IEEE Military Communications Conference 2010, pp. 864-869, November 2010. J. Ahrenholz, C. Danilov, T. Henderson, and J.H. Kim, CORE: A real-time network emulator, Proceedings of IEEE MILCOM Conference, 2008.  节点类型 CORE中可以配置不同的节点类型，每个节点类型都表示节点在运行时将如何表示的机器类型。不同的机器类型允许不同的选择。\nNetns 节点 netns(net nodes) 类型是默认的节点类型， 这是用于由 Linux 网络命名空间支持的节点。这种机器类型很少使用系统资源来模拟网络。这被指定为默认机器类型的另一个原因是，此技术通常不需要更改内核，它可从最新的主流Linux发行版中开箱即用。\n物理 节点 physical 机器类型用于表示真正的基于linux的机器的节点，这些机器将参与模拟的网络场景。该节点通常用于合并来自模拟测试平台的服务器机组。物理节点是运行CORE守护进程(CORE-daemon)的节点，它不会被进一步分区到容器中。在物理节点上运行的服务不是在一个隔离的环境中运行，而是直接在操作系统上运行。\n必须给物理节点分配服务器，与使用分布式仿真（Distributed Emulation）将节点分配仿真服务器的方式相同。可用物理节点列表当前与仿真服务器共享同一个对话框和列表，可以使用Session菜单中的emulation servers…条目进行访问。\n对物理节点的支持正在开发中，并可能在未来的版本中得到改进。目前，当任何节点连接到一个物理节点时，会画一条虚线来表示网络隧道。将在物理节点上创建一个GRE隧道接口，用于隧道通信流进出模拟世界。\n在运行时双击物理节点将打开一个终端，该终端带有指向该节点的SSH shell。用户应该像使用仿真服务器那样配置公钥SSH登录。\nCore 常见问题：   无法使用子节点终端的图形界面：\n# 报错提示 No protocol specified Error: Can't open display: :0  解决：Xserver默认情况下，不允许别的用户的图形程序的图形显示在当前屏幕上。在图形正常的用户终端中输入 xhost +\nxhost + # access control enabled, only authorized clients can connect xhost - # access control disabled, only authorized clients can connect    Xterm下的Tcpdump 抓包不刷新问题： 使用 -l 选项，设置stdout行缓冲， 这样也可以有效搭配如下命令\ntcpdump -l | tee dat tcpdump -l \u0026gt; dat \u0026amp; tail -f dat\t#终止时tcpdump未终止 记得kill pid    iperf3等流量测试工具在走分布式场景时会发生数据无法传输问题： 由于分布式之间的数据通过隧道链接，而建立的隧道默认MTU为1458字节。所以当分布式服务器的路由包的MTU过大时，不会转发数据。 以iperf3为例，设定传输流量包mss为1024就能解决无法传输跨分布式服务器的包的数据\niperf -c 192.168.131.161 -M 1024 #注意，这里的-M设定的是MSS为TCP、STCP传输层概念，MTU为传输层传递的最大IP包    ","id":0,"section":"posts","summary":"笔记实时更新中。。 Core、Emane 介绍 官方文档 一句话概括: CORE侧重于模拟如网络层传输层、会话层和应用层，提供了用户构建虚拟网络的图形","tags":["仿真"],"title":"Core 学习笔记","uri":"https://liangkang233.github.io/2021/07/core%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","year":"2021"},{"content":"CORE/EMANE Emane 介绍 EMANE 源码\nEMANE 教程\n可扩展移动自组织网络仿真器 (The Extendable Mobile Ad-hoc Network Emulator) 允许使用可插拔 MAC 和 PHY 层架构进行异构网络仿真。EMANE是由美国海军研究实验室(NRL)代号5522和 Adjacent Link 有限责任公司开发的。EMANE 框架提供了一种实现架构，用于以网络仿真模块 (NEM) 的形式对不同的无线电接口类型进行建模，并将这些模块合并到在分布式环境中运行的实时仿真中。\n http://www.adjacentlink.com/  可以使用 EMANE 绑定到虚拟设备的 EMANE 来模拟高保真无线网络，而不是使用 CORE 构建 Linux 以太网网桥。CORE 仿效第 3 层及以上（网络、会话、应用程序）及其虚拟网络堆栈和处理空间，用于协议和应用程序，而 EMANE 则使用其可插入的 PHY 和 MAC 模型模拟物理层和数据链路层。\nCore和 EMANE 之间的接口是 TAP 设备。CORE 使用 Linux 网络名称空间构建虚拟节点，将 TAP 设备安装到名称空间中，并在名称空间中即时化一个 EMANE 过程。EMANE 过程将用户空间Socket与 TAP 设备绑定，以便从 CORE 发送和接收数据。\nEMANE 实例通过控制端口（例如ctrl0 ，ctrl1）发送和接收 OTA（空中）流量来往于其他 EMANE 实例。它还使用相同或不同的控制端口发送和接收事件来回事件服务。通过 CORE 的WLAN配置对话配置 EMANE 模型。每个支持的 EMANE 模型都有相相应的Emane Python 子类，以提供配置项目及其对 XML 文件的映射。这样，新配置就可以很容易地得到支持。当 CORE 开始模拟时，它会生成指定 EMANE NEM 配置的相应 XML 文件，并启动 EMANE daemon\n某些 EMANE 模型支持位置信息，以确定何时应丢弃数据包。EMANE 具有一个事件系统，其中位置事件广播给所有 NEM。当节点在画布上移动时，CORE 可以生成这些位置事件。画布大小和比例对话具有将 X，Y 坐标系统映射到 EMANE 使用的纬度、经度地理系统的控件。还可以在core.conf配置文件设定CORE订阅 EMANE 位置事件，这样core gui画布上的节点与EMANE 仿真中时节点的会同步移动。例如，当模拟脚本生成器运行移动脚本时，就会发生这种情况。\n 下面的每个主题都假设已经安装了CORE、EMANE和OSPF MDR。演示文件将在新的core-pygui中找到\n   主题 模型 描述 总结     XML Files RF Pipe 概述生成的用于驱动EMANE的XML文件    GPSD RF Pipe 概述gpsd与EMANE的运行和集成    Precomputed RF Pipe 概述如何使用预计算传播模型    EEL RF Pipe 概述如何使用仿真事件日志(EEL)生成器    Antenna Profiles RF Pipe 概述如何在EMANE中使用天线配置文件      EMANE Configuration CORE 配置文件 /etc/core/core.conf 包含EMANE特有选项，如下所示：\n# EMANE 配置 emane_platform_port = 8101 emane_transform_port = 8201 emane_event_monitor = False # emane_models_dir = /home/username/.core/myemane # EMANE log 范围[0,4] 默认: 2 emane_log_level = 2 emane_realtime = True # emane安装地址前缀 # emane_prefix = /usr  如果你有一个EMANE事件生成器(例如移动或路径损耗脚本)，并且想让CORE订阅EMANE位置事件，在 CORE.conf 配置文件中设置以下行。\n NOTE: 如果要手动拖动画布上的节点来更新它们在EMANE中的位置，设置为 False\n emane_event_monitor = True  另一个常见的问题是，如果从源代码安装EMANE，默认配置前缀将把DTD文件放在 /usr/local/share/emane/dtd\n而core.com希望他们在 /usr/share/emane/dtd\n更新EMANE前缀配置可以解决此问题。\nemane_prefix = /usr/local  自定义EMANE模型 CORE通过动态加载用户创建的表示模型的python文件来支持自定义开发的EMANE模型。\n自定义的EMANE模型应该放在CORE配置文件中 emane_models_dir 所定义的路径中。这个路径不能以 /emane 结尾。\n下面是一个用文档描述功能的示例模型:\n\u0026quot;\u0026quot;\u0026quot; Example custom emane model. \u0026quot;\u0026quot;\u0026quot; from typing import Dict, List, Optional, Set from core.config import Configuration from core.emane import emanemanifest, emanemodel class ExampleModel(emanemodel.EmaneModel): \u0026quot;\u0026quot;\u0026quot; 自定义 emane 模型. :cvar name: 定义将在GUI中显示的emane模型名称 Mac Definition: :cvar mac_library: 定义模型将引用的MAC库 :cvar mac_xml: 定义MAC清单文件，它将被解析以获得配置选项，这将在GUI中显示 :cvar mac_defaults: 允许您重写上面清单文件中维护的选项 :cvar mac_config: 解析清单文件并将配置转换为core支持的格式 Phy Definition: 注意: Phy配置将默认为通用模型如下所示，下面的部分非必须包括在内 :cvar phy_library: 定义模型将引用的phy库，在需要提供自定义phy时使用 :cvar phy_xml: 定义phy清单文件，该文件将被解析以获得配置选项，将在GUI中显示 :cvar phy_defaults: 允许您重写上面清单文件中维护的选项或默认通用模型的选项 :cvar phy_config: 解析清单文件并将配置转换为Core心支持的格式 Custom Override Options: 注意: 这些选项默认为下面所见的内容，不需要包括在内 :cvar config_ignore: 允许您忽略phy/mac中的选项，通常在您需要添加一个自定义选项以在GUI中显示时使用 \u0026quot;\u0026quot;\u0026quot; name: str = \u0026quot;emane_example\u0026quot; mac_library: str = \u0026quot;rfpipemaclayer\u0026quot; mac_xml: str = \u0026quot;/usr/share/emane/manifest/rfpipemaclayer.xml\u0026quot; mac_defaults: Dict[str, str] = { \u0026quot;pcrcurveuri\u0026quot;: \u0026quot;/usr/share/emane/xml/models/mac/rfpipe/rfpipepcr.xml\u0026quot; } mac_config: List[Configuration] = emanemanifest.parse(mac_xml, mac_defaults) phy_library: Optional[str] = None phy_xml: str = \u0026quot;/usr/share/emane/manifest/emanephy.xml\u0026quot; phy_defaults: Dict[str, str] = { \u0026quot;subid\u0026quot;: \u0026quot;1\u0026quot;, \u0026quot;propagationmodel\u0026quot;: \u0026quot;2ray\u0026quot;, \u0026quot;noisemode\u0026quot;: \u0026quot;none\u0026quot; } phy_config: List[Configuration] = emanemanifest.parse(phy_xml, phy_defaults) config_ignore: Set[str] = set()  单主机EMANE 本节描述在单个机器上运行CORE和EMANE。这是使用CORE构建EMANE网络时的默认操作模式。\nOTA管理器和Event服务接口被设置为使用ctrl0，虚拟节点使用主控制通道进行相互通信。\n当涉及到EMANE的场景时，主控制通道会自动激活。使用主控制通道可以防止模拟会话在本地\n网络上发送多播流量，并干扰其他EMANE用户。\nEMANE是通过一个WLAN节点配置的，因为它完全是关于模拟无线无线电网络的。\n一旦节点连接到使用EMANE模型配置的WLAN云，该节点上的无线电接口也可以单独配置(除了云之外)。\n双击WLAN节点以调用WLAN配置对话框。单击EMANE选项卡;正确安装EMANE后，EMANE无线模块应列在\nEMANE型号列表中。(如果在安装EMANE Python绑定之前运行CORE守护进程，则可能需要重新启动它)\n单击一个模型名称来启用它。\n当在 EMANE Models 列表中选择一个EMANE模型时，单击 model options 按钮导致GUI查询\nCORE daemon 以获取配置项。每个模型都会有不同的参数，请参考每个项目的解释的EMANE文档。\n默认值显示在对话框中。单击 Apply 将存储EMANE模型选择。\nEMANE options 按钮允许指定一些Emane 全局参数，其中一些是分布式操作所必需的。\nRF-PIPE 和 IEEE 802.11abg 模型使用支持地理位置信息的通用PHY来确定节点之间的路径损耗。\n一个默认的经纬度位置由CORE提供，这个基于位置的路径损耗默认启用;这是通用PHY的路径损耗模式设置。\n在模拟运行时移动画布上的节点将为EMANE生成位置事件。\n要查看或更改画布的地理位置或比例，请使用画布菜单中的“画布大小和比例”对话框。\n注意，地理坐标系和笛卡尔坐标系之间的转换是使用通用墨卡托投影(UTM: Universal Transverse Mercator)完成的，\n其中定义了6层不同的经度带区域。对于跨越多个UTM区域的非常大的场景，CORE生成的位置事件在区域边界附近可能变得不准确。\n在这种情况下，建议使用EMANE位置脚本来实现地理位置的准确性。\n单击绿色的 Start 按钮将启动模拟，并导致在连接到EMANE WLAN的虚拟节点中创建TAP设备。\n这些设备显示为接口名称，如eth0、eth1等。EMANE进程现在应该在每个名称空间中运行。如下为四个节点的场景:\nps -aef | grep emane root 1063 969 0 11:46 ? 00:00:00 emane -d --logl 3 -r -f /tmp/pycore.59992/emane4.log /tmp/pycore.59992/platform4.xml root 1117 959 0 11:46 ? 00:00:00 emane -d --logl 3 -r -f /tmp/pycore.59992/emane2.log /tmp/pycore.59992/platform2.xml root 1179 942 0 11:46 ? 00:00:00 emane -d --logl 3 -r -f /tmp/pycore.59992/emane1.log /tmp/pycore.59992/platform1.xml root 1239 979 0 11:46 ? 00:00:00 emane -d --logl 3 -r -f /tmp/pycore.59992/emane5.log /tmp/pycore.59992/platform5.xml  上面的示例显示了CORE启动的EMANE进程。要查看CORE生成的配置，请查看/tmp/pycore。\n这是一个用于存放 platform.xml 文件和其他 XML文件的 session目录。\n查看这些信息的一种简单方法是双击其中一个虚拟节点，然后键入cd ..在shell中转到会话目录。\n分布式 EMANE 在两个或多个模拟服务器中运行CORE和EMANE与在单个机器上运行类似。 为了仿真能够运行，需要设置一些关键的配置项，这里概述了这些配置项。\n维护 数据(OTA流量)和控制流量为独立的网络是一个好主意。例如，控制网络可能是一个共享的实验室网络， core不希望数据网络上的多播通信干扰其他EMANE用户。此外，控制流量可能会干扰OTA延迟和吞吐量， 并可能影响仿真的保真度。这里描述的示例将使用eth0作为控制接口，使用eth1作为数据接口， 尽管并不严格要求使用单独的接口。注意，这些接口名称指的是物理主机上的接口，而不是节点内的虚拟接口。\n重要事项:如果使用了辅助控制网络，则需要将主机上的一个接口分配给该网络\n作为模拟服务器的每台机器都需要安装CORE和EMANE。\n可用服务器的IP地址从核心仿真服务器对话框中配置(选择 Session 然后 Emulation servers\u0026hellip; )。 这个服务器列表存储在*~/.core/servers.conf*文件中。对话框显示了可用的服务器， 其中的一部分或全部可以分配给画布上的节点。\n需要将节点分配给仿真服务器。选择几个节点，右键单击它们，选择Assign to和所需服务器的名称。 当未将节点分配给任何仿真服务器时，将在本地对其进行仿真。GUI连接的本地机器被认为是“主”机器， 而主机器又连接到其他模拟服务器的“从属”。应该配置从主服务器到从服务器的公钥SSH登录 具体请看分布式\n 注意 下面是使用EMANE进行分布式模拟的快速检查表。\n  遵循常规CORE的步骤。 在EMANE WLAN的 EMANE 标签下，单击 EMANE options 。 打开 OTA Manager channel ，设置 OTA Manager device 。同时设置 Event Service device 。 选择节点组，右键单击它们，并使用 assign to 菜单将它们分配给主或从服务器。 在开始模拟之前，使用 ntp 或 ptp 同步机器的时钟。一些EMANE模型对时间很敏感。 按 Start 按钮启动分布式仿真。  现在，当使用Start按钮实例化模拟时，本地CORE Python守护进程将连接到已分配给节点的其他模拟服务器。 每个服务器都有自己的会话目录，其中生成platform.xml文件和其他EMANE XML文件。NEM id在服务器之间自动协调， 因此没有重叠。每个服务器还获得自己的平台ID。\n以太网设备用于传播组播EMANE事件，如 configure EMANE 对话框中所指定的。EMANE的事件服务可以通过移动性 或路径损耗脚本运行，如单主机Emane所述。 如果CORE没有订阅位置事件，它将在画布上移动节点时生成这些事件。\n在运行时双击节点将导致GUI尝试SSH到该节点的仿真服务器，并运行交互式shell。在启动模拟之前， 应该使用所有模拟服务器对公钥SSH配置进行测试。\n","id":1,"section":"posts","summary":"CORE/EMANE Emane 介绍 EMANE 源码 EMANE 教程 可扩展移动自组织网络仿真器 (The Extendable Mobile Ad-hoc Network Emulator) 允许使用可插拔 MAC 和 PHY 层架构进行异构网络仿真。EMANE是由美国海军研究实验室(NR","tags":["仿真"],"title":"Emane学习记录","uri":"https://liangkang233.github.io/2021/07/emane/","year":"2021"},{"content":"服务 CORE 使用服务的概念来指定节点启动时运行哪些进程或脚本。路由器和PC等第三层节点是由他们所运行的服务来定义的。\n可以为每个节点定制服务，也可以创造新的自定义服务。可以创建具有不同名称、图标和默认服务集的新节点类型。 每个服务定义每个节点的路径、配置文件、启动索引、启动命令、验证命令、关闭命令和与节点关联的元数据。\n 注意: 使用 init, upstart, 或 systemd 框架时，网络名称节点空间不会经历正常的Linux引导过程 ，这些轻量节点使用已经配置好的CORE服务。\n 提供的服务    服务组 服务 总结     BIRD BGP, OSPF, RADV, RIP, Static    EMANE Transport Service    FRR BABEL, BGP, OSPFv2, OSPFv3, PIMD, RIP, RIPNG, Zebra    NRL arouted, MGEN Sink, MGEN Actor, NHDP, OLSR, OLSRORG, OLSRv2, SMF    Quagga BABEL, BGP, OSPFv2, OSPFv3, OSPFv3 MDR, RIP, RIPNG, XPIMD, Zebra    SDN OVS, RYU    Security Firewall, IPsec, NAT, VPN Client, VPN Server    Utility ATD, Routing Utils, DHCP, FTP, IP Forward, PCAP, RADVD, SSF, UCARP    XORP BGP, OLSR, OSPFv2, OSPFv3, PIMSM4, PIMSM6, RIP, RIPNG, Router Manager     节点类型和默认服务 以下是默认节点类型和他们的服务:\n   节点类型 服务     router 针对IGP链路状态路由的 zebra, OSFPv2, OSPFv3, and IPForward 服务。   host 默认路由和SSH服务, 其表示直接连接到路由器时，SSH具有默认路由。   PC 为拥有默认路由且直接连接到路由器的节点提供默认路由服务.   mdr 针对无线优化的 MANET 指定路由的 zebra、 OSPFv3MDR 和 IPForward 服务。   prouter 和 路由器 节点类型具有相同默认服务的物理路由器; 用于将Linux测试平台设备合并到仿真中。    配置文件可以由每个服务自动生成。例如，CORE 会自动为路由器节点生成路由协议配置，来简化虚拟网络的创建。\n更改与节点相关联的服务，可以双击节点来调用配置对话框, 然后单击 服务\u0026hellip; 按钮，或者右键单击某个节点，从右键菜单中选择 服务\u0026hellip; 选项。通过单击服务的名称可以启用或禁止该服务。每个服务名称旁边的按钮允许您为该节点自定义此服务的所有方面。例如，可以将特殊的路由重分发命令插入到与 zebra 服务关联的 Quagga 路由配置中。\n若要更改与节点类型相关的默认服务, 请使用第三层节点工具栏末端的 编辑 按钮中的 节点类型\u0026hellip; 对话框，或是从 会话 菜单中选择 节点类型\u0026hellip;。 注意，如果已经定制了节点，那么所选择的任何新服务都不会应用于现有节点。\n节点类型被保存在 ~/.core/nodes.conf 文件中，而不是 .imn 文件。在更改现有节点的默认服务时请记住这一点; 最好只创建一个新的节点类型。并且建议不要更改默认的内置节点类型。可以在 CORE 设备之间复制nodes.conf 文件来保存你的自定义类型。\n定制服务 可以为特定节点完全定制服务。 从节点的配置对话框中，单击服务名称旁边的按钮，来调用该服务的服务定制对话框。该对话框有三个选项卡用于配置服务的不同方面：Files， Directories和tartup/shutdown。\n 注意: 服务旁边的 黄色 自定义图标表示服务需要自定义（例如 防火墙 服务）。绿色 的自定义图标表示存在自定义配置。在自定义服务时单击 默认 按钮会移除所有自定义选项。\n Files选项卡用于显示或编辑用于该服务的配置文件或脚本。文件可以从下拉列表中选择，它们的内容将显示在下面的文本框中。文件的内容由 CORE daemon根据自定义对话框调用时存在的网络拓扑进程生成。\nDirectories选项卡显示该服务的每个节点的路径。对于默认类型，CORE节点共享相同的文件系统树，但被服务定义的每个节点除外。例如，对于每个运行 Zebra 服务的节点，其 /var/run/quagga 路径必须是唯一的，因为在每个节点运行的 Quagga 需要向该路径写入单独的 PID 文件。\n 注意: 默认情况下， /var/log 和 /var/run 路径按照每个节点唯一挂载。每个节点的挂载目标可以在 /tmp/pycore.nnnnn/nN.conf/ （其中 nnnnn 是会话编号，N是节点编号）中找到。\n Startup/shutdown 选项卡列出用于启动和停止该服务的命令。 startup index允许在该服务启动时对为该节点启用的其他相关服务进行配置；Startup较低的服务先于Startup较高的服务. 由于Files选项卡生成的shell脚本没有执行权限设置，因此启动命令应包含shell名称，类似于 sh script.sh。\nShutdown 命令可选择终止与此服务关联的进程。通常，它们使用 kill 或 killall 命令向正在运行的进程发送kill 信号。如果服务没有使用 Shutdown 命令终止正在运行的进程，那么当终止 vnoded 守护进程(使用 kill -9命令)并摧毁命名空间时，进程将被杀死。指定 shutdown 命令是一个很好的实践，这将允许适当的进程终止，以及停止和重启服务的运行控制。\nValidate 命令按照启动命令执行。 Validate 命令可以执行应返回0值的流程或者脚本，对于启动出现问题的服务返回非0值。例如，pidof 命令将检查某个进程是否正在运行，是则返回0值。当 Validate 命令生成了一个非零返回值，这将产生一个异常而导致在 Check Emulation Light 中显示一个错误。\n 注意: 在运行时启动、停止和重启服务，需要右键单击节点并使用 服务\u0026hellip; 菜单。\n 新的服务 服务可以节省配置节点所需的时间，特别是当大量节点都需要类似的配置程序时。此时可以引入新的服务来使任务自动化。\n利用用户自定义 将新流程的配置捕获到服务中的最简单方法是使用 UserDefined 服务。这是一个空白服务，可以自定义其中的任何方面。 UserDefined 服务便于在添加新的服务类型之前测试服务。\n创建新的服务   修改如下所示的实例服务，以便做您想做的事情。它可以生成配置/脚本文件、每个节点的挂载路径、启动进程/脚本等。sample.py 是一个 Python 文件，它定义了一个或更多需要导入的类。您可以创建多个将被导入的Python文件。将任何新文件名添加到 init.py 文件中。\n  把这些文件放在诸如 /home/username/.core/myservices 这样的路径中。但应注意路径最后的名称 myservices 不应该命名为类似于与现有的Python名称冲突的 服务（使用的语法是 from myservices import *'）\n  添加命令 custom_services_dir = /home/username/.core/myservices 到 /etc/core/core.conf 文件中。\n注意: 在 custom_services_dir 使用的路径名应该是唯一的，并且不应该对应于任何现有的Python模块名。例如，不要使用 subprocess 或是 services 名称。\n  重启 CORE 守护进程 (core-daemon). 任何导入错误 (Python 语法)都应显示在 /var/log/core-daemon.log 日志文件上（或显示在屏幕上）。\n  开始在节点上使用自定义服务吧。您可以创建使用您的服务的新节点类型，或者更改现有节点的默认服务，又或者更 改单个节点。\n  如果您已经创建了一个可能对他人有用的新服务类型，请考虑将其贡献给 CORE 项目。\n自定义服务示例 下面是带有一些说明文档的自定义服务框架。大多数人可能只会设置所需的类变量 (name/group)。然后定义 configs （他们想要生成的文件），并实现 generate_config 函数来动态创建所需的文件。最后，被提供的 startup 命令通常倾向于运行生成的shell文件。\n\u0026quot;\u0026quot;\u0026quot; Simple example custom service, used to drive shell commands on a node. \u0026quot;\u0026quot;\u0026quot; from typing import Tuple from core.nodes.base import CoreNode from core.services.coreservices import CoreService, ServiceMode class ExampleService(CoreService): \u0026quot;\u0026quot;\u0026quot; Example Custom CORE Service :cvar name: name used as a unique ID for this service and is required, no spaces :cvar group: allows you to group services within the GUI under a common name :cvar executables: executables this service depends on to function, if executable is not on the path, service will not be loaded :cvar dependencies: services that this service depends on for startup, tuple of service names :cvar dirs: directories that this service will create within a node :cvar configs: files that this service will generate, without a full path this file goes in the node's directory e.g. /tmp/pycore.12345/n1.conf/myfile :cvar startup: commands used to start this service, any non-zero exit code will cause a failure :cvar validate: commands used to validate that a service was started, any non-zero exit code will cause a failure :cvar validation_mode: validation mode, used to determine startup success. NON_BLOCKING - runs startup commands, and validates success with validation commands BLOCKING - runs startup commands, and validates success with the startup commands themselves TIMER - runs startup commands, and validates success by waiting for \u0026quot;validation_timer\u0026quot; alone :cvar validation_timer: time in seconds for a service to wait for validation, before determining success in TIMER/NON_BLOCKING modes. :cvar validation_period: period in seconds to wait before retrying validation, only used in NON_BLOCKING mode :cvar shutdown: shutdown commands to stop this service \u0026quot;\u0026quot;\u0026quot; name: str = \u0026quot;ExampleService\u0026quot; group: str = \u0026quot;Utility\u0026quot; executables: Tuple[str, ...] = () dependencies: Tuple[str, ...] = () dirs: Tuple[str, ...] = () configs: Tuple[str, ...] = (\u0026quot;myservice1.sh\u0026quot;, \u0026quot;myservice2.sh\u0026quot;) startup: Tuple[str, ...] = tuple(f\u0026quot;sh {x}\u0026quot; for x in configs) validate: Tuple[str, ...] = () validation_mode: ServiceMode = ServiceMode.NON_BLOCKING validation_timer: int = 5 validation_period: float = 0.5 shutdown: Tuple[str, ...] = () @classmethod def on_load(cls) -\u0026gt; None: \u0026quot;\u0026quot;\u0026quot; Provides a way to run some arbitrary logic when the service is loaded, possibly to help facilitate dynamic settings for the environment. :return: nothing \u0026quot;\u0026quot;\u0026quot; pass @classmethod def get_configs(cls, node: CoreNode) -\u0026gt; Tuple[str, ...]: \u0026quot;\u0026quot;\u0026quot; Provides a way to dynamically generate the config files from the node a service will run. Defaults to the class definition and can be left out entirely if not needed. :param node: core node that the service is being ran on :return: tuple of config files to create \u0026quot;\u0026quot;\u0026quot; return cls.configs @classmethod def generate_config(cls, node: CoreNode, filename: str) -\u0026gt; str: \u0026quot;\u0026quot;\u0026quot; Returns a string representation for a file, given the node the service is starting on the config filename that this information will be used for. This must be defined, if \u0026quot;configs\u0026quot; are defined. :param node: core node that the service is being ran on :param filename: configuration file to generate :return: configuration file content \u0026quot;\u0026quot;\u0026quot; cfg = \u0026quot;#!/bin/sh\\n\u0026quot; if filename == cls.configs[0]: cfg += \u0026quot;# auto-generated by MyService (sample.py)\\n\u0026quot; for iface in node.get_ifaces(): cfg += f'echo \u0026quot;Node {node.name} has interface {iface.name}\u0026quot;\\n' elif filename == cls.configs[1]: cfg += \u0026quot;echo hello\u0026quot; return cfg @classmethod def get_startup(cls, node: CoreNode) -\u0026gt; Tuple[str, ...]: \u0026quot;\u0026quot;\u0026quot; Provides a way to dynamically generate the startup commands from the node a service will run. Defaults to the class definition and can be left out entirely if not needed. :param node: core node that the service is being ran on :return: tuple of startup commands to run \u0026quot;\u0026quot;\u0026quot; return cls.startup @classmethod def get_validate(cls, node: CoreNode) -\u0026gt; Tuple[str, ...]: \u0026quot;\u0026quot;\u0026quot; Provides a way to dynamically generate the validate commands from the node a service will run. Defaults to the class definition and can be left out entirely if not needed. :param node: core node that the service is being ran on :return: tuple of commands to validate service startup with \u0026quot;\u0026quot;\u0026quot; return cls.validate  ","id":2,"section":"posts","summary":"服务 CORE 使用服务的概念来指定节点启动时运行哪些进程或脚本。路由器和PC等第三层节点是由他们所运行的服务来定义的。 可以为每个节点定制服务，也可以","tags":["仿真"],"title":"Core services","uri":"https://liangkang233.github.io/2021/07/services/","year":"2021"},{"content":"CORE 分布式仿真 概述 大型模拟场景可以部署在多个模拟服务器上由单个Core-GUI控制。表示整个拓扑的GUI可以是 其中一台模拟服务器或单独的只运行GUI的机器。\n作为模拟的每台机器都需要安装一个分布式CORE包和一些允许root用户使用ssh的配置。\nCORE 配置 使用分布式功能所需的核心配置设置：\n最好先了解CORE的控制网络章节内容\ncore运行的配置文件默认为 /etc/core/core.conf 可以修改该文件来配置core的相关参数，或者运行core-daemon时指定自定义的配置文件(-f 选项)\n# 取消注释并将其设置为远程服务器的地址 # 此地址用于主控网络返回至主机，即为主服务器真实IP地址 distributed_address = 129.168.0.101 # 不配置Emance默认所有分布式服务器和主控制服务器使用同一主控制网段 # 仿真中所有节点都会分配一个该网段内IP并将节点attach每台服务器对应的主控网桥上 # 各分布式主网桥数据会直接汇总到主服务器的控制网桥，服务器的主控制网络会自动建立一个隧道联通物理网卡eth0和主控网桥 controlnet = 172.16.0.0/24  若是单独跑分布式数据，这里主控网不配置也是能走通的，可不开启。\n分布式 EMANE 特定配置 EMANE 需要在 core.conf 中配置 controlnet 才能正确启动。 地址前的名称需要与配置的分布式服务器的名称相匹配。\n# 与上面所有分布式服务器的主控制网桥使用同一网段（在同一局域网内）不同 # 分布式Emance要求每一台分布服务器的主控制网桥工作在不同网段 # 最后各分布式服务器主控网桥的数据会通过隧道汇总到主控网络 controlnet = core1:172.16.1.0/24 core2:172.16.2.0/24 core3:172.16.3.0/24 core4:172.16.4.0/24 core5:172.16.5.0/24 emane_event_generate = True  配置 SSH 分布式CORE使用python fabric库在远程服务器上通过SSH运行命令。\n远程 GUI 终端 您需要在每个服务器上定义相同的用户，因为运行CORE GUI的用户会登录相同用户的远程bash（ssh）\nEdit -\u0026gt; Preferences\u0026hellip; -\u0026gt; Terminal program: 目前建议将此设置为xterm -e作为默认值，gnome-terminal无法工作。 如果没有安装，可能需要安装xterm\nsudo apt install xterm  分布式服务器SSH配置 首先，必须将分布式服务器配置为允许通过SSH进行无密码的root用户登录，或者分布式服务器插入主服务器的公钥免密登录。\n在分布式服务器上如此配置：\n# 安装 openssh-server sudo apt install openssh-server # 打开 sshd 配置 vi /etc/ssh/sshd_config # 验证这些配置是否启用 PermitRootLogin yes PasswordAuthentication yes # 如果需要，添加/修改以下行以允许SSH # 接受所有env变量 AcceptEnv * # 重启 sshd sudo systemctl restart sshd  在主服务器上：\n# 安装环境所需包 sudo apt install openssh-client  法1：公钥登录（推荐）\n# 在主服务器上生成SSH公、密钥 # 要确保生成的公钥密钥文件的绝对路径是 ~/.ssh，如下所示密钥文件为core，公钥文件为core.pub ssh-keygen -o -t rsa -b 4096 -f ~/.ssh/core # 将公钥复制到从服务器地址server的authorized_keys文件中（需输入密码登录） ssh-copy-id -i ~/.ssh/core root@server # 当然运行core-gui的user用户也需要如上配置，否则无法打开远程终端 # 配置fabric使用Core SSH密钥 sudo vi /etc/fabric.yml # 添加/修改配置文件，其中路径中的user改为对应用户名 connect_kwargs: {\u0026quot;key_filename\u0026quot;: \u0026quot;/home/user/.ssh/core\u0026quot;}  法2：设置无需密码登录\n# 在分布式服务器上，打开 sshd 配置 vi /etc/ssh/sshd_config # 将root登录的配置更改为不需要密码 PermitRootLogin without-password # 重启 sshd sudo systemctl restart sshd  在 GUI 中添加仿真服务器 在 core-gui 的导航菜单中： Session -\u0026gt; Emulation servers\u0026hellip; 在出现的对话框中，添加或修改现有服务器（如果存在）以使用您计划使用的服务器的名称、地址和端口（真实环境下参数）\n服务器配置默认加载到下面的GUI 的配置文件 ~/.core/servers.conf\n# 名字 地址 端口 server2 192.168.0.2 4038  分配节点 用户需要为场景中的仿真服务器分配节点。不分配意味着节点将在主服务器上模拟。在每个节点的配置窗口中，位于Node name和Image按钮之间的下拉框将选择模拟服务器的名称。默认情况下，此菜单显示 (none)，表示该节点将在 master 上本地模拟。进入执行模式时，CORE GUI 将在其分配的仿真服务器上部署节点。\n分配仿真服务器的另一种方法是使用选择工具选择一个或多个节点（按住 Ctrl 键单击以选择多个），然后右键单击其中一个节点并选择 Assign to\u0026hellip;.\nCORE emulation servers对话框也可以用于为服务器分配节点。分配的服务器名称显示在节点名称旁边的括号中。要将所有节点分配给其中一台服务器，请单击服务器名称，然后单击all nodes按钮. 已分配节点的服务器在服务器列表中显示为蓝色. 另一种选择是先选择一个节点子集, 然后打开CORE emulation servers 选项并使用 selected nodes 按钮.\n注意: 如果要在主服务器上运行这些节点，则不要分配它们。无需显式地将节点分配给主服务器\nGUI 可视化 如果位于不同服务器上的两个节点之间存在链接，GUI将用虚线绘制链接。\n问题和局限性   无线模型\n只有当 EMANE 模型用于 WLAN 时，无线节点，即连接到 WLAN 节点的那些节点，才能被分配到不同的仿真服务器并参与相同的无线网络。由于使用了 Linux 网桥和 ebtables 规则，basic无线模型不能跨多个服务器工作\n  主从服务器流量\n自己测试发现，所有仿真中节点跨从服务器数据都是先发送到主服务器上再转发至从服务器，而且主控制网络路由也是需要主服务器转发。从服务器数量增多后势必导致主服务器转发路由负荷过大。正在测试能否使用控制网间的隧道或其他方法使从服务器间有直接联通的链路，而非主服务器转发。\n  注意: basic无线模型不支持分布式仿真，但EMANE支持\n当节点跨服务器链接时， core-daemons将在执行时自动在节点之间创建必要的隧道。应注意安排拓扑以使隧道的数量最小化。隧道在服务器之间传送数据以连接拓扑中指定的节点。这些隧道是使用 GRE 隧道创建的，类似于隧道工具\n分布式配置清单  在主服务器上安装 CORE 在所有需要的服务器上安装分布式 CORE 包 在所有服务器上安装和配置公钥 SSH 访问（如果想要使用双击打开终端或是窗口部件）为 GUI 用户（用于终端）和 root 运行 CORE 命令 根据需要更新 CORE 配置 选择参与分布式仿真的服务器 将节点分配给所需的服务器，若是节点在主服务器仿真则不分配（NONE）。 主服务器按start按钮启动分布式仿真，分服务器无须开启gui和daemon  ","id":3,"section":"posts","summary":"CORE 分布式仿真 概述 大型模拟场景可以部署在多个模拟服务器上由单个Core-GUI控制。表示整个拓扑的GUI可以是 其中一台模拟服务器或单独的只运行","tags":[""],"title":"Core 分布式","uri":"https://liangkang233.github.io/2021/07/distributed/","year":"2021"},{"content":"CORE 控制网络（CTRL NET） 概述 CORE 控制网络允许虚拟节点与其宿主环境进行通信。有两种类型：主控制网络和辅助控制网络。主控制网络主要用于与主机的虚拟节点通信以及多服务器分布式环境中的主从通信。辅助控制网络的功能为将由命名空间托管的仿真软件流量路由至测试网络场景。\n激活主控制网络 在 Session Menu有一个选项来设置 control network prefix.\n这可以设置为网络前缀（网段），例如 172.16.0.0/24。将在网段范围内的最后一个地址（例如 172.16.0.254）的主机上创建一个网桥，并且每个节点将有一个额外的 ctrl0 控制接口，并配置一个与其节点号相对应的ip地址（例如172.16.0.3 表示 n3)\n还可以通过在 /etc/core/core.conf 配置文件中设置 controlnet 行来指定主控制网络的默认值，新会话将默认使用该行。要同时使用控制网络运行多个会话，应使用 session 选项而不是 core.conf 默认值\n 注意: 如果您有超过 253 个节点的大型场景，请使用 /23 或更大的网段。\n  注意: 如果前一个会话已设置控制网络并且其网桥仍在运行，则继续使用控制网络运行会话可能会失败。首先关闭上一个会话或等待它完成。如果不能，则可能需要重新启动核心守护程序并手动删除延迟的桥接器\n # 重启 CORE Daemon sudo /etc/init.d core-daemon restart # 移除残留的控制网桥 ctrlbridges=`brctl show | grep b.ctrl | awk '{print $1}'` for cb in $ctrlbridges; do sudo ifconfig $cb down sudo brctl delbr $cb done   **注意:**如果在 /etc/core/core.conf 中对主控制网络配置所做的调整似乎没有生效，请检查Session Menu, the *Options\u0026hellip;*对话框中是否有任何设置，它们可能需要清除。这些会话的设置会覆盖 /etc/core/core.conf 中的默认值。\n 分布式会话中的控制网络 当主控制网络做为分布式会话激活时，将在每个从服务器上创建一个控制网桥，并通过GRE隧道返回到主服务器的网桥。从控制网桥没有分配地址，可以从主机访问任何节点(本地或远程)，就像单个服务器的情况一样。\n在某些情况下，远程模拟节点需要与运行它们的主机而不是主服务器进行通信。可以在会话选项或 /etc/core/core.conf 中指定多个控制网络前缀，以空格分隔并以主服务器开头。每个条目的格式为 server:prefix 。如下所示，更改 /etc/core/core.conf 默认配置，为服务器 core1、core2 和 core3 分配了控制网络网段。也可在会话session选项中设定。\ncontrolnet=core1:172.16.1.0/24 core2:172.16.2.0/24 core3:172.16.1.0/24  然后，控制网桥将被分配如下\n* core1 = 172.16.1.254 （假设它是主服务器） * core2 = 172.16.2.254 * core3 = 172.16.3.254  仍将构建从服务器导向主服务器的隧道，但如果需要在控制网络前缀之间建立网络，则需要用户添加适当的路由。控制网络脚本可能对此有所帮助。\n控制网络脚本 可以使用 /etc/core/core.conf 文件中的 controlnet_updown_script 选项指定控制网络脚本。该脚本将在网桥建成（并分配地址）后运行，命令的第一个参数是网桥的名称，第二个参数是关键字 “startup”。该脚本将在移除桥时会再次被调用，命令的第一个参数是网桥的名称，命令的第二个参数是关键字 “shutdown”。该脚本默认位置在~/core/daemon/examples/controlnet_updown中。\n辅助控制网络 从 EMANE 0.9.2 开始，CORE 将在命名空间内运行 EMANE 实例。由于建议将 OTA 流量与其他流量分开，因此我们将需要多个从命名空间导出的通道。最多可以定义三个辅助控制网络。 /etc/core/core.conf 文件中设置了多个控制网络。线路 controlnet1、controlnet2 和 controlnet3 定义辅助网络。\n例如 /etc/core/core.conf 中配置如下\ncontrolnet = core1:172.17.1.0/24 core2:172.17.2.0/24 core3:172.17.3.0/24 controlnet1 = core1:172.18.1.0/24 core2:172.18.2.0/24 core3:172.18.3.0/24 controlnet2 = core1:172.19.1.0/24 core2:172.19.2.0/24 core3:172.19.3.0/24  这将激活主控制网络controlnet和两个辅助控制网络，并向每个节点添加接口 ctrl0、ctrl1、ctrl2。例如在 EMANE 选项对话框中将 ctrl1 分配给 OTA 管理器设备，将 ctrl2 分配给事件服务设备，并将 ctrl0 留给 CORE 控制流量（主控网络）\n NOTE: controlnet0 可以用来代替 controlnet 来配置主控制网络\n 与主控制网络不同，辅助控制网络不会使用隧道，因为它们的主要目的是有效地传输多播 EMANE OTA 和事件流量。\n请注意，辅助控制网络没有针对每个会话的配置\n为了在分布式测试环境中扩展辅助控制网络，需要向其中添加主机网络接口。 /etc/core/core.conf 中的以下几行将主机设备的 eth1、eth2 添加到 controlnet1、controlnet2：\ncontrolnetif1 = eth1 controlnetif2 = eth2   NOTE: 无需为主控制网络分配接口，因为使用servers.conf 中提供的IP 地址在主设备和从设备之间形成隧道\n 下图是上述配置的示意图：\n","id":4,"section":"posts","summary":"CORE 控制网络（CTRL NET） 概述 CORE 控制网络允许虚拟节点与其宿主环境进行通信。有两种类型：主控制网络和辅助控制网络。主控制网络主要用于与主机的","tags":[""],"title":"Core 控制网络","uri":"https://liangkang233.github.io/2021/07/ctrlnet/","year":"2021"},{"content":"Core 环境搭建 推荐使用Vscode编辑代码，可以安装对应python扩展。\n# 更新软件包索引，并且安装依赖软件： sudo apt update # 启用 Visual Studio Code 源仓库，输入： sudo apt install software-properties-common apt-transport-https wget # 使用 wget 命令插入 Microsoft GPG key ： wget -q https://packages.microsoft.com/keys/microsoft.asc -O- | sudo apt-key add - # 启用 Visual Studio Code 源仓库: sudo add-apt-repository \u0026quot;deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable main\u0026quot; sudo apt install code  安装quagga等组件\nsudo apt-get install quagga quagga-doc libtk-img \\ openssh-server isc-dhcp-server isc-dhcp-client \\ vsftpd apache2 tcpdump radvd at ucarp openvpn \\ ipsec-tools racoon traceroute mgen wireshark \\ iperf3 tshark snmpd snmptrapd openssh-client sudo setcap 'CAP_NET_RAW+eip CAP_NET_ADMIN+eip' /usr/bin/dumpcap sudo adduser $USER wireshark  安装Core 依照手册教程即可：列出遇到的问题。推荐安装core在虚拟环境中（默认选项）\n# 更新python和pip python3 -m pip install -U pip # 或者直接apt-get sudo apt install python3 python3-pip # clone CORE repo git clone https://github.com/coreemu/core.git cd core # 脚本用法: install.sh [-v] [-d] [-l] [-p \u0026lt;prefix\u0026gt;] # -v enable verbose install # -d enable developer install # -l enable local install, not compatible with developer install # -p install prefix, defaults to /usr/local # install core to virtual environment ./install.sh -p \u0026lt;prefix\u0026gt; # install core locally ./install.sh -p \u0026lt;prefix\u0026gt; -l    自动安装脚本install.sh将会执行以下工作\n 安装安装所需的基础工具python3, pip, pipx, invoke, poetry 为构建Core安装系统依赖 clone/build/install OPSF MDR 的工作版本 通过传入参数标志，设定将Core安装到poetry管理的虚拟环境中或真实环境中 根据安装类型来安装适当的Python位置的指向脚本 根据安装类型来安装适当的Python位置的systemd服务    运行软件安装脚本install.sh报错或无效时会直接停止导致后续命令不执行。\n如果是因为模块已经安装过，打开脚本进行查看对应安装命令，卸载需要删掉的环境模块即可。\n  Invok命令的使用：\n其实install脚本就是运行invoke对应选项的安装，使用如下教程来进行core的安装卸载\ninv --list #list 指令选项: daemon #运行 core-daemon install #安装 core, poetry, scripts, service, ospf mdr install-emane #安装 emane and the python bindings install-scripts #安装 core 脚本执行文件, 修改以利用虚拟环境 install-service #安装 systemd core 服务 test #运行 core tests test-emane #运行 core emane tests test-mock #运行 core tests 使用 mock 来避免以管理员(sudo)来执行 uninstall #卸载 core, scripts, service, virtual environment, 清理 build 目录 #安装的详细帮助信息 inv -h install Usage: inv[oke] [--core-opts] install [--options] [other tasks here ...] Docstring: install core, poetry, scripts, service, and ospf mdr Options: -d, --dev 安装开发模式 -p STRING, --prefix=STRING 设置脚本安装路径，默认是/usr/local -v, --verbose 启用 verbose    关于汉化gui界面的重装\n# 先卸载 sudo make uninstall make clean ./bootstrap.sh clean #安装 ./bootstrap.sh ./configure make sudo make install # 上述代码就是早期版本的生成和卸载  # 新版本直接使用invoke卸载重装整个即可,当然有需要可以在invole脚本对应的task.py中添加instal-core，如下所示 @task() def reinstall_core( c, dev=False, verbose=False, local=False, prefix=DEFAULT_PREFIX, install_type=None ): \u0026quot;\u0026quot;\u0026quot; reinstall core by LK233 \u0026quot;\u0026quot;\u0026quot; hide = not verbose p = Progress(verbose) c.run(\u0026quot;sudo -v\u0026quot;, hide=True) print(f\u0026quot;uninstalling core with prefix: {prefix}\u0026quot;) with p.start(\u0026quot;uninstalling core\u0026quot;): c.run(\u0026quot;sudo make uninstall\u0026quot;, hide=hide) with p.start(\u0026quot;cleaning build directory\u0026quot;): c.run(\u0026quot;make clean\u0026quot;, hide=hide) c.run(\u0026quot;./bootstrap.sh clean\u0026quot;, hide=hide) print(f\u0026quot;installing core with prefix: {prefix}\u0026quot;) with p.start(\u0026quot;building core\u0026quot;): build_core(c, hide, prefix) with p.start(\u0026quot;installing vcmd/gui\u0026quot;): install_core(c, hide)    整个core套件卸载重装时遇到的问题\n由于卸载脚本运行时没有卸载虚拟环境中的poetry，导致之后运行安装脚本invoke报错停止。可以通过在安装脚本添加\u0026ndash;force强制安装或卸载脚本添加卸载poetry代码解决，最快的解决办法（core安装在虚拟环境的情况）卸载后在core的根目录执行\npipx uninstall poetry\n  安装Emane 自动安装脚本安装的Emane版本为1.25，Core虚拟环境安装仅支持Emane1.21以上版本\ninvoke脚本任务能自动安装Emane，它从源代码来构建安装Emane，但在较老的Protobuf编译器上的系统存在问题。\n# 安装Emane到core虚拟环境中 inv install-emane # 安装到真实python环境 inv install-emane -l  EMANE也可以从deb、RPM包git源码安装。需要注意的是，如果Emane安装在本地python环境(安装Emane到真实环境教程)需要将EMANE python绑定安装到CORE虚拟环境virtualenv中。如下所示：\n# 克隆和构建Emane python绑定 git clone https://github.com/adjacentlink/emane.git cd emane ./autogen.sh PYTHON=python3 ./configure --prefix=/usr cd src/python make # 安装到core虚拟环境 cd \u0026lt;CORE_REPO\u0026gt;/daemon poetry run pip install \u0026lt;EMANE_REPO\u0026gt;/src/python  运行core   要测试CORE Network Emulator是否工作，请启动CORE守护进程和GUI。 首先，启动CORE守护进程:\nsudo service core-daemon start #直接开新终端运行，方便看日志 sudo core-daemon #守护进程帮助手册 -h -f CONFIGFILE, --configfile CONFIGFILE 读取配置文件CONFIGFILE，默认是/etc/core/core.conf -p PORT, --port PORT 设定port为守护进程监听端口，默认4038 --ovs 启用实验ovs模式，默认为false --grpc-port GRPCPORT 设定GRPCPORT为GRPC监听端口，默认50051 --grpc-address GRPCADDRESS 设定GRPCADDRESS为监听grpc地址;默认本地主机 -l LOGFILE, --logfile LOGFILE 设置LOGFILE为守护进程日志选项，默认为/etc/core/logging.conf，错误日志为core-daemon.log  如果在安装CORE后没有重新启动，此时可能会遇到错误。如果您看到告诉您文件core守护进程的错误。 服务不存在，请重新启动系统。重新启动后，再次尝试启动core守护进程服务。 然后，运行CORE GUI\ncore-gui    如果你创建自己的python脚本来直接运行CORE或者使用gRPC/TLV api，你需要确保你是在安装的虚拟环境的上下文中运行它们。为了帮助支持这个CORE提供了CORE-python可执行文件。这个可执行文件将允许你进入CORE的python虚拟环境解释器或在其中运行脚本。\ncore-python \u0026lt;script\u0026gt;  若是安装在真实环境中直接执行\npython3 \u0026lt;script\u0026gt;    Quigga配置（非必要） 我们将在OSPF中使用Quagga进行第一次实验，设置Quagga守护进程配置文件:\nsudo touch /etc/quagga/zebra.conf sudo touch /etc/quagga/ospfd.conf sudo touch /etc/quagga/ospf6d.conf sudo touch /etc/quagga/ripd.conf sudo touch /etc/quagga/ripngd.conf sudo touch /etc/quagga/isisd.conf sudo touch /etc/quagga/pimd.conf sudo touch /etc/quagga/vtysh.conf sudo chown quagga.quaggavty /etc/quagga/*.conf sudo chown quagga.quaggavty /etc/quagga/*.conf sudo chmod 666 /etc/quagga/*.conf  编辑Quagga守护进程文件。\nsudo nano /etc/quagga/daemons  新文件应该如下所示\nzebra=yes bgpd=no ospfd=yes ospf6d=no ripd=no ripngd=no isisd=no babeld=no  设置环境变量，以避免Ubuntu Linux中的Quagga vysh END问题。\nsudo bash -c 'echo \u0026quot;export VTYSH_PAGER=more\u0026quot; \u0026gt;\u0026gt;/etc/bash.bashrc' sudo bash -c 'echo \u0026quot;VTYSH_PAGER=more\u0026quot; \u0026gt;\u0026gt;/etc/environment'  Core文件介绍 下面是运行自动安装后将安装的文件列表。\n **注:**默认的安装前缀是/usr/local，但可以更改如下所示\n  执行文件  \u0026lt;prefix\u0026gt;/bin/{core-daemon, core-gui, vcmd, vnoded, etc}   tcl/tk gui 文件  \u0026lt;prefix\u0026gt;/lib/core \u0026lt;prefix\u0026gt;/share/core/icons   示例场景 imn 文件  \u0026lt;prefix\u0026gt;/share/core/examples   python 文件  poetry 虚拟环境  cd \u0026lt;repo\u0026gt;/daemon \u0026amp;\u0026amp; poetry env info ~/.cache/pypoetry/virtualenvs/   本地python安装  default install path for python3 installation of a wheel python3 -c \u0026quot;import core; print(core.__file__)\u0026quot;     配置文件  /etc/core/{core.conf, logging.conf}   ospf mdr 仓库文件  \u0026lt;repo\u0026gt;/../ospf-mdr   emane 仓库文件  \u0026lt;repo\u0026gt;/../emane    执行文件 安装完成后，它将安装以下脚本。\n   名称 描述     core-cleanup 删除工具，帮助删除Core创建的容器，网桥，目录   core-cli 运行支持的Core服务器，提供TLV和gRPC api   core-daemon runs the backed core server providing TLV and gRPC APIs   core-gui 运行传统的基于tcl/tk的GUI   core-imn-to-xml 帮助自动将.imn文件转换为.xml格式的工具   core-manage 用于添加、移除或检查|中的服务、模型和节点类型的工具   core-pygui 运行新的的基于Python的GUI   core-python 运行core虚拟环境内的python   core-route-monitor 帮助监控节点间的流量并将其提供给SDT的工具   core-service-update 更新修改遗留服务以匹配当前命名的工具   coresendmsg 从命令行发送TLV API命令的工具    ","id":5,"section":"posts","summary":"Core 环境搭建 推荐使用Vscode编辑代码，可以安装对应python扩展。 # 更新软件包索引，并且安装依赖软件： sudo apt update # 启用 Visual Studio Code 源仓库，输入： sudo","tags":[""],"title":"Core Emane环境搭建","uri":"https://liangkang233.github.io/2021/07/installation/","year":"2021"},{"content":" Core 架构 Python API gRPC API  Core架构 主要组件   Core守护(服务)进程 (core-daemon)\n 该程序是利用小型C二进制文件来创建节点的Python仿真程序 管理网络节点、链路的仿真会话 使用Linux命名空间创建节点 链路是由Linux网桥和虚拟以太网设备TAP等创建的 链路数据包是通过流量控制来操纵的 仿真过程可以由CORE GUI控制 提供自定义TLV API和gRPC API    Core界面 (core-gui)\n GUI和守护进程通过自定义TLV API进行通信 拖放节点和链接的创建 可以在运行的会话中启动仿真节点的终端 可以保存/打开场景文件重新创建以前的会话 TCL/TK 程序    Core消息 (coresendmsg)\n 用于将TLV API消息发送到核心守护进程的命令行实用程序    虚拟命令终端 (vcmd)\n 用于向节点发送shell命令的命令行实用程序    会话Sessions CORE可以同时创建和运行多个模拟会话，下面表格从左向右概述了典型GUI交互期间会话将转换的状态。\n   定义初始化 配置参数 安装模拟节点 运行仿真 数据采集 停止仿真     XML/IMN 会话Gui绘制脚本 配置hooks、配置服务、配置移动性和WLAN、配置Emance 创建节点、接口桥接链路、启动服务 移动性仿真、交互shell、状态设定脚本  关闭服务销毁接口、桥接链路、节点    工作原理 CORE框架运行在Linux上，并使用Linux命名空间创建节点容器。这些节点使用Linux网桥和虚拟接口连接在一起。CORE会话是一组节点和链接，它们出于特定目的一起工作。Linux网络名称空间(也称为netns: Linux network namespaces )是CORE使用的主要技术。大多数最新的Linux发行版都具有开箱即用的支持名称空间的内核。每个命名空间都有自己的进程环境和私有的网络堆栈。网络名称空间在CORE中共享相同的文件系统。CORE将这些名称空间与Linux以太网桥接结合起来，形成网络。使用Linux Netem排队规则应用链接特性。Ebtables是Linux桥上的以太网帧过滤方法，通过使用ebtables规则控制哪些接口可以发送和接收来模拟无线网络。\n之前的工作 Tcl/Tk CORE GUI最初起源于萨格勒布大学的开源IMUNES项目，作为波音研究与技术网络技术研究小组2004年的一个定制项目。从那时起，他们开发了使用Linux命名空间的CORE框架，开发了一个Python框架，并进行了大量的用户和内核空间开发，例如支持无线网络、IPsec、分布式仿真、仿真集成等等。IMUNES项目还包括用户空间和内核组件。\n开源项目和资源 CORE已经由波音在BSD许可下发布给开源社区。如果您发现CORE对您的工作有用，请返回到项目中。贡献可以像报告bug、向邮件列表提供鼓励或技术建议一样简单，也可以包括提交补丁或维护工具的各个方面。\nPython API 挖坑中。。。 😲\ngRPC API 挖坑中。。。 😲\n","id":6,"section":"posts","summary":"Core 架构 Python API gRPC API Core架构 主要组件 Core守护(服务)进程 (core-daemon) 该程序是利用小型C二进制文件来创建节点的Python仿真程序 管理网络节点、链路的","tags":[""],"title":"Core 仿真架构","uri":"https://liangkang233.github.io/2021/07/architecture/","year":"2021"},{"content":"使用 CORE GUI 下图显示 CORE GUI:\n概述 GUI 用于在画布上绘制节点和网络设备，将它们连接在一起，以创建模拟的网络会话。\n按下启动按钮后，CORE 将通过这些阶段进行，保持在运行时阶段。会话停止后，CORE 将进入数据收集阶段，然后卸载模拟状态。\nCORE 可自定义以在每个状态执行任何操作。有关何时达到这些会话状态，请参阅会话菜单上的Hooks\u0026hellip;\n必要条件 除了安装CORE之外，还必须运行CORE守护进程。\n在命令行中使用systemd或sysv。\n# systemd sudo systemctl daemon-reload sudo systemctl start core-daemon # sysv sudo service core-daemon start  还可以直接从命令行调用守护进程，如果您想直接查看日志输出，这很有用。\n# direct invocation sudo core-daemon  操作模式 核心GUI有两种主要操作模式，编辑和执行模式。运行GUI，通过键入没有选项Core-gui，从编辑模式开始。节点使用左侧的工具栏绘制在空白画布上，并从右键单击菜单或双击菜单进行配置。GUI 不需要作为root运行。\n编辑完成后，按下绿色**\u0026ldquo;开始\u0026rdquo;**按钮（或从**会话**菜单中选择**执行**）会因 Linux 内核中的拓扑，然后进入执行模式。在执行模式下，用户可以通过双击或右键单击运行模拟的计算机进行交互。编辑工具栏消失，由执行工具栏替换，该工具栏在运行仿真时提供工具。按下红色**停止**按钮（或从**会话**菜单中选择**终止**）将破坏运行模拟并将 CORE 返回到编辑模式。\nCORE可以通过指定启动和命令行上的拓扑文件直接在执行模式下启动：\ncore-gui --start ~/.core/configs/myfile.imn  一旦模拟开始运行，就可以关闭GUI，并出现提示询问是否应该终止仿真。之后运行时，GUI会提示重新连接到现有的会话。\nGUI可以在Linux上以普通用户的身份运行。GUI可以连接到不同的地址或TCP端口使用**\u0026ndash;address**和/或**\u0026ndash;port**选项。默认值如下所示。\ncore-gui --address 127.0.0.1 --port 4038  工具栏 工具栏是一排按钮，沿Core gui窗口的左侧垂直运行。工具栏会根据操作模式而变化。\n编辑工具栏 当 CORE 处于编辑模式（默认值）时，垂直编辑工具栏位于核心窗口的左侧。\n以下是从顶部开始的每个工具栏项的简要说明。大多数工具被分组到相关的子菜单中，当您单击其组图标时会出现这些子菜单。\n   图标 名字 描述      选择工具 用于选择、移动、配置节点的工具。    启动按钮 开始执行模式，实例化模拟节点。    链接 允许通过单击和拖动鼠标在两个节点之间绘制网络链接。    核心节点 这些节点将创建一个新的节点容器并运行相关服务。\n   图标 名字 描述      路由器 运行Quagga OSPFv2和OSPFv3路由转发数据包。    主机 模拟服务器机具有默认路线，运行SSH服务器。    个人电脑 具有默认路线的基本模拟机器，默认情况下不运行任何进程。    指定路由器移动自组网协议（ MANET Designated Routers） 运行 Quagga OSPFv3 MDR 路由，用于管理优化路由。（MANETs: Mobile Ad Hoc Networks 移动自组网）    物理路由器（PRouter） 物理路由器代表了一个真实的试验机器。    编辑 生成自定义节点对话。    网络节点 这些节点主要用于创建一个 Linux 网桥，用于以下目的。\n   图标 名字 描述      集线器hub 以太网集线器将传入的数据包转发到每个连接的节点。    交换机Switch 以太网交换机使用以太网地址哈希表智能地将传入的数据包转发给附加主机。    Wireless LAN 当路由器连接到此 WLAN 节点时，它们会加入无线网络，并绘制天线而不是连接线：WLAN节点通常根据连接的距离控制连接无线节点之间的连接。    RJ45 RJ45物理接口工具，仿真节点可链接到真正的物理接口：使用此工具，真正的网络和设备可以物理连接到实时运行模拟。    Tunnel Tool allows connecting together more than one CORE emulation using GRE tunnels.    注释工具    图标 名字 描述      Marker 用于在画布上绘制标记。    Oval 用于在背景中显示的画布上绘制圆圈。    Rectangle 用于在背景中显示的画布上绘制矩形。    Text 用于在画布上放置文本字幕。    执行工具栏 按下\u0026quot;开始\u0026quot;按钮后，CORE 切换到\u0026quot;执行\u0026quot;模式，核心窗口左侧的编辑工具栏替换为执行工具栏，下面是此工具栏上的项，从顶部开始。\n   图标 名字 描述      Selection Tool 在执行模式下，选择工具可用于在画布周围移动节点，在节点上双击将打开该节点的外壳窗口：右键单击节点会调用该节点的运行时间选项的弹出菜单。    Stop Button 停止执行模式，终止仿真，将 CORE 返回到编辑模式。    Observer Widgets Tool 单击此放大镜图标可调用菜单以轻松选择\u0026quot;观察者小部件\u0026quot;。当\u0026quot;观察者小部件\u0026quot;处于活动状态时，图标具有较深的灰色背景，在此期间，将鼠标移到节点上会弹出该节点的信息显示。    Marker 用于在画布上画手线，在演示期间有用：标记未保存。    Two-node Tool 单击以选择开始和结束节点，并在这些节点之间运行一次性跟踪路由或节点之间连续*ping-R。*输出实时显示在结果框中，而 IP 地址则解析，并在 CORE 显示屏上突出显示完整的网络路径。    Run Tool 此工具允许轻松地在所有节点的全部或子集上运行命令。列表框允许选择任何节点。文本输入框允许输入任何命令。命令应立即返回，否则显示屏将阻止等待响应。例如，没有参数的ping命令不是个好主意。每个命令的结果都显示在结果框中。特殊文本\u0026quot;NODE\u0026quot;的第一次出现将替换为节点名称。命令不会尝试在不是路由器、PC 或主机的节点上运行，即使它们被选中。    菜单 菜单栏沿 CORE GUI 窗口的顶部运行，并提供对各种功能的访问。某些菜单可以通过单击顶部的虚线来分离，例如小部件菜单。\n查看菜单 \u0026ldquo;视图\u0026quot;菜单包含用于控制绘图画布上显示的内容的项目。\n   Option Description     Show Opens a submenu of items that can be displayed or hidden, such as interface names, addresses, and labels. Use these options to help declutter the display. These options are generally saved in the topology files, so scenarios have a more consistent look when copied from one computer to another.   Show hidden nodes Reveal nodes that have been hidden. Nodes are hidden by selecting one or more nodes, right-clicking one and choosing hide.   Locked Toggles locked view; when the view is locked, nodes cannot be moved around on the canvas with the mouse. This could be useful when sharing the topology with someone and you do not expect them to change things.   3D GUI\u0026hellip; 运行Preferences， 3D GUI command下定义的命令启动3D GUI。这通常是一个运行SDT3D显示的脚本。SDT是NRL的脚本显示工具，它基于美国宇航局基于java的WorldWind虚拟地球软件。   Zoom In Magnifies the display. You can also zoom in by clicking zoom 100% label in the status bar, or by pressing the + (plus) key.   Zoom Out Reduces the size of the display. You can also zoom out by right-clicking zoom 100% label in the status bar or by pressing the - (minus) key.    工具菜单 工具菜单列出了不同的实用功能。\n   选择 描述     Autorearrange all 自动排列画布上的所有节点。具有更多链接的节点移动到中心。此模式可以在放置节点时继续运行。要关闭此自动重新排列模式，请单击带有选定工具的画布空白区域，或再次选择此菜单选项。   Autorearrange selected 自动排列画布上选定的节点。   Align to grid 将节点移动到网格形成中，从画布左上角的最小编号节点开始，在垂直柱中排列节点。   Traffic\u0026hellip; 调用 CORE 流量流对话框，允许为模拟配置、启动和停止 MGEN 流量流。   IP addresses\u0026hellip; 调用 IP 地址对话框来配置自动处理新接口时使用的 IPv4/IPv6 前缀。   MAC addresses\u0026hellip; 调用 MAC 地址对话框来配置生成每个接口 MAC 地址时用作最低分节的起始编号。在进行 CORE 模拟之间的隧道时，应更改此值，以防止 MAC 解决冲突。   Build hosts file\u0026hellip; 调用\u0026quot;构建主机文件\u0026quot;对话框，根据仿真中使用的 IP 地址生成**/etc/host**文件条目。   Renumber nodes\u0026hellip; 调用\u0026quot;重新编号节点\u0026quot;对话框，允许在点击数时将一个节点编号与另一个节点编号交换。   Experimental\u0026hellip; 实验选项的菜单，如转换ns-2脚本到IMUNES imn拓扑，只支持基本的ns-2功能，以及一个自动划分拓扑到分区的工具。   Topology generator 打开要生成的拓扑的子菜单。您可以首先选择拓扑应该包含的节点类型，否则将默认选择路由器。节点可以随机放置、在网格中对齐或各种其他拓扑模式。下表列出了所有受支持的模式。   Debugger\u0026hellip; 打开Core Debugger执行任意 Tcl/Tk 命令。    拓扑发生器    模式 描述     随机 节点随机放置在画布上，但未链接在一起。这可以与 WLAN 节点一起快速创建无线网络。   网 格 节点位于水平行中，从左上角开始，均匀地向右间隔：节点之间不链接。   已连接的网格 节点位于 N x M（宽度和高度）矩形网格中，每个节点都连接到上面、下面、左侧和右侧的节点。   链 节点在链条中一个接一个地连接在一起。   星 一个节点放置在中心，N 节点以圆形模式环绕，每个节点都链接到中心节点。   周期 节点以圆形模式排列，每个节点都连接到其邻居，形成封闭的圆形路径。   轮子 车轮模式将节点连接在星形和循环模式的组合中。   立方体 生成节点的立方体图。   全连接 创建一个结点的分队图，每个节点都连接到所有其他节点。   二分图 创建两个节点的双分方图，具有两组脱节的顶点。    部件菜单 小部件是 GUI 元素，允许与运行模拟进行交互。小部件通常自动在模拟节点上运行命令，以报告某种类型的状态信息并在屏幕上显示这些信息。\n周期性部件 这些小部件是主小部件菜单中可用的。其中多个小部件可以同时运行。事件循环每秒发射一次，模拟正在运行。如果启用了其中一个小部件，则此时将调用其周期性例程。每个小部件可能有一个配置对话框，也可以从小部件菜单访问。\n下面是一些标准部件：\n 邻接- 显示Quagga’s OSPFv2和OSPFv3路由协议的路由器对接状态。从每个路由器中抽取一条线，中途到相邻路由器的路由器 ID。线的颜色基于 OSPF 的对会状态，如Two-way 或 Full。要了解不同的颜色，请参阅配置邻接…菜单项，vtysh命令用于转储 OSPF 邻居信息。只绘制了一半的线，因为每个路由器可能处于与另一个路由器不同的对等状态。 吞吐量- 使用ng_pipe Netgraph节点收集的统计数据来实现显示每个链接上方的每秒千位吞吐量。如果吞吐量超过一定阈值，链接将变得突出显示。对于向范围内的所有节点广播数据的无线节点，吞吐率显示在节点旁边，如果阈值超出，节点将变得圆圈化。  观察部件 这些小部件可从小部件菜单的**\u0026ldquo;观察者小部件\u0026quot;子菜单以及工具栏上的\u0026quot;小部件工具\u0026quot;中获取。一次只能使用一个观察者小部件。在会话运行时，鼠标在节点上弹出有关该节点的信息显示。\n可用的观察者小部件包括 IPv4 和 IPv6 路由表、socket信息、运行过程列表和 OSPFv2/v3 邻居信息。\n观察者小部件可以由用户编辑并重新排列。从\u0026quot;观察者小部件\u0026quot;菜单中选择编辑将调用\u0026quot;观察者小部件\u0026quot;对话。显示观察者小部件列表以及用于重新排列列表的上下箭头。控件可用于重命名每个小部件、更改鼠标运行期间运行的命令以及从列表中添加和删除项目。请注意，指定命令应立即返回，以避免 GUI 显示屏出现延迟。更改将保存到 CORE 配置目录中的widgets.conf文件。\n会话菜单 除了节点类型、注释、钩子、服务器和选项等全局选项外，会话菜单还有启动、停止和管理会话的条目。\n   Option Description     Start or Stop 启动或停止仿真，执行与绿色启动或红色停止按钮相同的功能。   Change sessions\u0026hellip; 调用包含守护进程的活动CORE会话列表的CORE Sessions对话框。显示会话的名称、节点数、起始时间和缩略图等基本信息。这个对话框允许连接到不同的会话，关闭会话，或启动一个新的会话等功能。   Node types\u0026hellip; 调用核心节点类型对话框，执行与网络层节点工具栏上的编辑按钮相同的功能。   Comments\u0026hellip; 调用CORE Session Comments窗口，其中可以指定可选的文本注释。这些注释保存在配置文件的顶部，对于描述拓扑或如何使用网络非常有用。   Hooks\u0026hellip; 调用CORE Session Hooks窗口，其中脚本可以配置为特定的会话状态。会话状态定义在下面的表格中。窗口的顶部有一个已配置的钩子列表，左下方的按钮允许添加、编辑和删除钩子脚本。新建或编辑按钮将打开一个钩子脚本编辑窗口。hook脚本是在主机上(不是在虚拟节点内)调用的shell脚本。   Reset node positions 如果您已经使用鼠标或通过移动模块移动了节点，选择该项目将重置所有节点到它们在画布上的原始位置。当您第一次按下Start按钮时，就已经记录节点位置。   Emulation servers\u0026hellip; 调用CORE仿真服务器对话框进行配置。   Options\u0026hellip; 提供每个会话的选项，如是否使用的IPv4前缀，控制网络保存会话目录的能力，SDT3D支持的开/关等。    会话状态    状态 描述     定义 GUI 用来告诉后端清除任何状态。   配置 当用户按下*\u0026ldquo;开始\u0026rdquo;*按钮时，节点、链接和其他配置数据将发送到后端。当用户自定义服务时，也会达到此状态。   实例 在发送配置数据后，就在创建节点之前创建实例。   运行 所有节点和网络都已构建并正在运行。(这与前面命名的全局实验脚本运行时的状态相同。)   数据收集 用户已按下*\u0026ldquo;停止\u0026rdquo;*按钮，但在服务停止和节点被关闭之前。这是从节点收集日志文件和其他数据的好时机。   关闭 所有节点和网络都已被关闭和销毁。    连接物理网络 CORE 的模拟网络可实时运行，因此可以连接到实时物理网络。RJ45 工具和隧道工具有助于连接到现实世界。这些工具可从链接层节点菜单中获取。\n当两个或多个CORE仿真连接在一起时，应该避免MAC地址冲突。开始仿真时，CORE自动为各接口分配MAC地址，起始地址为00:00:00:aa:00:00，从底字节开始递增。第二台机器上的CORE的MAC起始地址应该改变以避免冲突，使用Tool菜单的 MAC地址… 选项来设定。\nRJ45 工具 CORE中的RJ45节点代表真实CORE机器上的一个物理接口。 任何真实世界的网络设备都可以连接到该接口并进行通信实时使用CORE节点。\n其主要缺点是每个连接都需要一个物理接口。当物理接口被分配给CORE时，它可能无法用于其他任何事情。另一个需要考虑的问题是，您所连接的计算机或网络必须与运行CORE仿真的机器位于同一局域网。\n单击“链路层节点”工具栏上，在子菜单中选择“RJ45”。单击要连接到的节点附近的画布，例如路由器、集线器、交换机或WLAN。现在点击链接工具，在RJ-45和另一个节点之间做一条链接。该RJ45节点将显示“UNASSIGNED”。双击RJ45节点，分配物理接口。将显示可用接口列表，可以双击列表中的接口名称进行选择，也可以在文本框中输入接口名称。\n 注意:当你按下Start按钮实例化你的拓扑时，分配给RJ45的接口将连接到CORE拓扑。系统无法再使用该接口。\n 如果使用802.1x VLAN，可以在CORE内部使用多个RJ45节点，并将其分配到同一个物理接口。这允许RJ45节点比物理网口更多。 但(例如交换机)硬件连接到物理端口必须支持VLAN标签，可用的带宽将被共享。\n您需要在Linux主机上创建单独的VLAN虚拟设备，然后将这些设备分配给CORE内部的RJ45节点。 VLANning实际上是在CORE外部执行的，所以当CORE模拟节点收到传输给Vlan的数据包时，会自动将VLAN tag移除。VLAN基本知识\n以下是在Linux下创建VLAN设备的命令示例:\nip link add link PHYS_DEV name.1 type vlan id 1 ip link add link PHYS_DEV name.2 type vlan id 2 ip link add link PHYS_DEV name.3 type vlan id 3  隧道工具 隧道工具在CORE仿真或其他主机之间构建GRE隧道。 当物理接口的数量有限或对等体位于不同的网络时，隧道技术会很有帮助。 物理接口也不需要像RJ45工具那样专用于CORE。\n对端GRE隧道端点可能是另一台支持GRE隧道的CORE机器或另一台主机。 当放置一个Tunnel隧道节点时，该节点最初将显示“UNASSIGNED”。 此处需要替换为隧道对接处的IP地址。这是另一个CORE机器或物理机器的IP地址，而不是另一个虚拟节点的IP地址。\n 注意 GRE设备可能存在的MTU(最大传输单元)问题。gre tap设备接口MTU为1458字节,当连接到Linux网桥时，网桥的MTU也变成1458字节。如果其他网桥端口具有更高的MTU(比如1500字节)，那个Linux网桥将不会对该大数据包执行分片。\n GRE密钥用于识别使用GRE隧道的流。这使得多个GRE隧道存在于同一对隧道对等体之间。 当多个隧道与同一个对等体使用时，应使用一个唯一的编号。 当配置隧道对端时，确保匹配的密钥为使用。\n下面是在Linux上构建隧道另一端的示例命令。 在这个例子中，CORE中的路由器拥有虚拟地址 10.0.0.20/24 ，Core主机（设为user1）的真实地址为192.168.163.130/24。 将与CORE机器连接的Linux机器（设为user2）可以通过真实的网络在192.168.163.133/24处访问。\n仿真路由器与Tunnel节点相连。在隧道节点配置对话框中，输入地址192.168.163.133，密钥为1。\n# 这些命令在匹配tunnel的用户user2上执行 sudo ip link add gt0 type gretap remote 192.168.163.130 local 192.168.163.133 key 1 # Linux机器上的gretap接口将从虚拟路由器节点的子网中分配一个地址10.0.0.22/24。 sudo ip addr add 10.0.0.22/24 dev gt0 sudo ip link set dev gt0 up  现在虚拟路由器应该可以ping通Linux机器User2了:\n# from the CORE router node ping 10.0.0.22 # 如果想要直接ping物理地址加条路由即可 ip route add 192.168.163.133 via 10.0.0.22  User2应该能够ping通内核仿真内部:\n# from the tunnel peer ping 10.0.0.20  要调试此配置，tcpdump可以在gretap设备上运行，也可以在CORE或Linux机器的物理接口上运行。 确保防火墙没有阻断GRE流量。\n与主机通信 节点不一定要可以访问到运行core-gui或core-daemon的主机。例如，在一个节点上运行一个X11应用程序可以使用特定的通信方式让应用程序连接到X服务器以进行图形化显示。有几种不同的方式可以从节点连接到主机，反之亦然。\n控制网络 通过控制网络是与主机连接的最快方式。 通过控制网络，主机可以在节点上启动X11应用程序。首先要在该节点上启用SSH服务，并且使用SSH来进行从主机到该节点的X11服务转发。\nSSH原理与运用（一）：远程登录 \nSSH原理与运用（二）：远程操作与端口转发\n# 节点n5使用ssh来转发主机运行x协议标准的时钟xclock程序界面 ssh -X 172.16.0.5 xclock  注意，可以使用coresendmsg将消息发送到主机上运行的CORE守护进程与运行的仿真交互 (需要 /etc/core/core.conf 的配置文件中设定监听地址为广播即 listenaddr = 0.0.0.0 ) 例如，一个节点可以通过上述方法移动自己或其他节点，或者根据某个节点的状态更改其图标。\n其他方法 还有其他方法可以将主机与节点连接起来。RJ-45工具可以配合虚拟接口访问节点:\n# 或者使用modprobe命令创建dummy设备 sudo modprobe dummy numdummies=1 # 但是使用ip link show无法查看到，不知是否失效， # 推荐使用ip命令创建 sudo ip link add dummy0 type dummy  主机上应该出现一个 dummy0 接口。使用RJ45工具分配给dummy0，并将其链接到您的场景中的一个节点。(相当于core仿真后会建立一个网桥，上述dummy0设备会attach到该网桥)会话启动后，需要在主机上配置地址。\nip link show type bridge # 根据上述命令确定core仿真的网桥名称 # 在与链接节点相同的网络上分配一个IP地址 sudo ip addr add 10.0.1.2/24 dev 该设备名  在上面的例子中，主机将有地址10.0.1.2，而连接到RJ45的节点可能有地址10.0.1.1。\n构建样本网络 有线网络 有线网络是使用链接工具创建的，以绘制两个节点之间的链接。这将自动绘制一条代表以太网链路的红线，并在网络层节点上创建新的接口。\n双击链接以调用链接配置对话框。在这里您可以更改该链路的带宽、延迟、丢失和重复速率参数。您还可以修改链接的颜色和宽度，从而影响其显示。\n链路层节点用于对有线网络进行建模。这些不会产生 一个单独的网络堆栈，而是使用Linux网桥实现。 这些是集线器、交换机和无线局域网节点。集线器从 每个连接的链路的传入链路，而交换机的行为更像是 以太网交换机，并跟踪连接的对等体的以太网地址， 只转发单播流量到适当的端口。\n无线网络 WLAN节点允许您构建无线网络，移动节点会影响它们之间的连接。一对节点之间越紧密，连接越强;节点之间越远连接越弱。无线局域网(WLAN)节点以小云的形式出现。根据您的建模需求，WLAN提供了多个级别的无线仿真保真度。\nWLAN工具可以通过插件进行扩展，以实现不同级别的无线保真度。基本的开/关范围是所有平台上可用的默认设置。其他插件以更高的复杂性和CPU使用量为代价提供更高的保真度。某些插件的可用性因平台而异。关于无线模型类型的简要概述，请参见下表。\n   模型 类型 支持平台 保真度 描述     basic on/off Linux Low 使用ebtables的以太网桥接   EMANE Plug-in Linux High TAP设备连接到EMANE模拟器的可插拔的MAC和PHY无线射频模型    要快速构建无线网络，您可以首先将多个路由器节点放置在画布上。如果您安装了 Quagga MDR 软件，建议您使用mdr节点类型来减少开销路由。接下来从链接层节点子菜单选择无线局域网。首先通过双击云图标设置所需的 WLAN 参数。然后，您可以通过右键单击 WLAN 并选择链接到所有路由器来链接所有路由器。\n将路由器连接到 WLAN 会导致出现小天线，但不会绘制红色链接线。路由器可以具有多个无线链接以及无线和有线链接（但是您需要重新手动设置路由。mdr 节点类型将生成路由配置，使 OSPFv3 具有 MANET 扩展。这是波音公司开发的对QuaggaOSPFv3的扩展，可减少洪泛费用，并优化移动临时（MANET）移动自组网络的洪泛过程。\nWLAN 的默认配置设置为使用基本basic模型，使用 WLAN 配置对话框中的基本选项卡。选择此模型会导致core-daemon基于屏幕像素位置来计算节点之间的距离。使用*范围滑块（Range slider）*为无线网络设置屏幕像素的数字范围。当两个无线节点在它们之间画了一条绿线，它们是相连的。两个距离超过像素距离的无线节点不被连接。在执行模式中，用户可以通过单击和移动无线节点拖动它们，无线链接就会被动态创建或断开。\nEMANE选项卡列出了可用于无线网络的可用 EMANE 模型。有关使用 EMANE 的详细信息，请参阅[EMANE](./Core Doc/Emane.md)章节。\n移动性脚本 CORE下述方法来设置脚本移动性。\n   选项 描述     ns-2 script 该脚本指定了绝对位置或具有速度的路径点。位置用笛卡尔坐标给出。   CORE API 外部实体可以通过发送带有更新的X,Y坐标的CORE API Node消息来移动节点;coresendmsg实用程序允许shell脚本生成这些消息。   EMANE events 有关使用EMANE脚本移动节点的详细信息，请参见[EMANE .md]。位置信息通常以纬度、经度和高度给出。    对于第一种方法，可以使用文本编辑器或BonnMotion之类的工具创建移动脚本，并将脚本与使用WLAN配置对话框中的一个无线连接起来，点击 ns-2 mobility script\u0026hellip;按钮, 并在 ns2script 中的配置对话框设置mobility script file字段\n下面是一个为10个节点创建BonnMotion脚本的示例:\nbm -f sample RandomWaypoint -n 10 -d 60 -x 1000 -y 750 bm NSFile -f sample # 上述脚本生成'sample.ns_movements'  在启动Execute模式并且其中一个WLAN节点具有移动性时 脚本时，将出现一个移动脚本窗口。此窗口包含控件 启动、停止和重置移动性脚本的运行时间，loop 复选框设置脚本连续重复调用。分辨率resolution 文本框包含每个计时器事件之间的毫秒数;较低的值使移动性看起来更流畅，但消耗更多的CPU时间。\nns-2移动脚本的格式如下:\n# nodes: 3, max time: 35.000000, max x: 600.00, max y: 600.00 $node_(2) set X_ 144.0 $node_(2) set Y_ 240.0 $node_(2) set Z_ 0.00 $ns_ at 1.00 \u0026quot;$node_(2) setdest 130.0 280.0 15.0\u0026quot;  前三行设置节点2的初始位置。上面例子中的最后一行导致节点2以速度15向目的地**(130,280)**移动。所有单位都是屏幕坐标，速度以每秒为单位。总脚本时间是在所有节点到达它们的路径点之后得到的。 最初，移动脚本对话框中的时间滑块并不准确。\n示例移动脚本(及其相关的拓扑文件)可以在**configs/**目录中找到。\n多画布 CORE 支持多个画布，用于组织模拟节点。在不同的画布上运行的节点可以链接在一起。要创建一个新的画布，从canvas菜单中选择* new *。一个新的画布标签出现在左下角。点击一个画布标签切换到它画布。双击其中一个选项卡来调用*Manage Canvases*对话框盒子。在这里，画布可以重命名和重新排序，你可以很容易地切换到并选择其中一幅画布。\n每个画布维护自己的一组节点和注释。画布之间要构建联系首先选择一个节点，右键单击它，选择Create link to，选择列表中的目标画布，以及该子菜单中的所需节点。之后将绘制一个伪链接，表示上两个节点之间的链接到不同的画布。双击箭头末端的标签即可跳转到它所链接的画布。\n检查仿真灯（CEL） CEL（Check Emulation Light）位于GUI的右下角，这是一个黄色图标，指示运行模拟中的一个或多个问题。单击CEL将调用CEL 对话框。Check Emulation Light对话框包含从CORE守护进程接收到的异常列表。异常列表包含有时间、严重级别、可选节点号和来源这些信息。当CEL闪烁时，这表示一个或多个致命异常。\n具有致命严重级别的异常表明无法创建模拟的一个或多个基本部分，例如无法创建桥或名称空间，或者无法为基于eman1的网络启动eman1进程。单击异常将显示该异常的详细信息。如果指定了节点号，当选中异常时，该节点将在画布上高亮显示。异常源是一个文本字符串，用于帮助跟踪异常发生的位置;例如，UserDefined服务的验证命令失败时，会出现\u0026rdquo; service:UserDefined \u0026ldquo;。\n对话框底部有一些按钮，用于清除异常列表和查看CORE守护进程和节点日志文件。\n 注意: 在批处理模式下，从CORE守护进程接收到的异常将显示在控制台上。\n 场景配置文件 场景配置拓扑文件保存为 .xml 或 .imn 。你可以轻松地编辑这些文件与文本编辑器。当您编辑拓扑时文件，您将需要停止模拟(如果它正在运行)并重新加载文件。\n.imn 文件格式来自IMUNES，主要成分是 节点、链接、etc的Tcl链表。 拓扑文件中的制表符Tab和空格有严格规范。该文件首先列出每个节点，然后列出链接、注释、画布和选项。每个实体都有一个包含在花括号中的块。第一个块缩进四个空格。 在network-config块(以及任何custom--config*块)中，缩进是一个制表符。\n 注意: 有几个拓扑示例包括在CORE中的：~/.core/configs, 如果Core安装到文件系统中则在 /usr[/local]/share/examples/configs.\n  注意: 当使用 Imn 文件格式，特定文件路径： CORE_DATA_DIR = /usr/share/core, CONFDIR = ~/.core/configs\n  注意: 您可以使用最喜欢的文本编辑器直接编辑文件。\n 定制您的拓扑外观 提供多个注释工具来改变您的拓扑呈现方式。文字工具可以添加字幕。椭圆形和矩形可能绘制在后台，有助于在视觉上将节点分组在一起。\n在实时演示期间，标记工具可能有助于在画布上绘制可能很快被擦除的临时注释。选择标记工具时，工具栏底部会出现大小和调色板。标记只是暂时的，不会保存在拓扑文件中。\n基本节点图标可以替换为您选择的自定义图像。图标在使用具有透明背景的 GIF 或 PNG 格式时显示得最好。要更改节点的图标，请双击节点以调用其配置对话框，然后单击显示节点当前图标的节点名称右侧的按钮。\n画布的背景图像可以使用 canvas 菜单中的 Wallpaper… 设置。图像可以居中、平铺或以中心做缩放来适应画布大小。例如，可以使用现有的地形、地图或网络图可以用作背景，并将CORE节点绘制在顶部。。\n偏好 Preferences对话框可以从Edit_Menu访问。此对话可以设置许多默认值，这些默认值存储在 ~/.core/prefs.conf 首选项文件中。\n","id":7,"section":"posts","summary":"使用 CORE GUI 下图显示 CORE GUI: 概述 GUI 用于在画布上绘制节点和网络设备，将它们连接在一起，以创建模拟的网络会话。 按下启动按钮后，CORE 将通过这些阶段进行","tags":[""],"title":"Core Gui","uri":"https://liangkang233.github.io/2021/07/gui/","year":"2021"},{"content":"go指南练习 新手初学Go语言，看到这个go指南网站在线测试很方便做了几道练习后就在上面学习。 其中最后一页的测试： go指南练习:web爬虫 学了go的并发基本使用方法后，觉得比c的多线程好写多了，所以最后的模拟web爬虫练习的代码贴出来，希望指教下怎么写更安全、高效。\n题目要求 /* 练习：Web 爬虫 在这个练习中，我们将会使用 Go 的并发特性来并行化一个 Web 爬虫。 修改 Crawl 函数来并行地抓取 URL，并且保证不重复。 提示：你可以用一个 map 来缓存已经获取的 URL， 但是要注意 map 本身并不是并发安全的！ */ // TODO: 并行的抓取 URL。 // TODO: 不重复抓取页面。 // Crawl 并没有实现上面两种情况：  修改部分 该代码其实是对伪造的fakeFetcher进行抓取，每个伪造结果map内的元素是一个结构体fakeResult。 该结构体元素由body字段（真正要展示的内容）和归属的urls。 Crawl函数调用Fetcher接口的fetcher方法对fakeResult的body字段匹配，并打印匹配到的body出来，没找到就打印报错。 若是匹配成功，Crawl深度减一递归的调用Crawl，url使用匹配body对应的fakeResult下的urls切片每一个url值。\n 要求使用并发的实现 所以为了不改变原函数模板采用sync.WaitGroup来进行主进程等待子进程结束。  // sync.WaitGroup 用法 var wg sync.WaitGroup wg.Add(i int) //添加i个worker协程 wg.Done()\t//该子进程结束，做记录 wg.Wait() //当worker协程未全部执行结束，会一直堵塞  要求使用map记录已经爬取的页面避免重复抓取 由于map非并发安全（多个goroutine同时写入map会报错），添加互斥锁解决。  // 带互斥锁的map，防止并行的写入 type SafeUrlMap struct { set map[string]int mux sync.Mutex } func (myset SafeUrlMap) add(url string) { myset.mux.Lock() // elem, ok = set[url] myset.set[url]++ myset.mux.Unlock() } func (myset SafeUrlMap) have(url string) bool { myset.mux.Lock() if myset.set[url] != 0 { defer myset.mux.Unlock() return true } return false }\t 完整代码 package main import ( \u0026quot;fmt\u0026quot; \u0026quot;sync\u0026quot; ) type Fetcher interface { // Fetch 返回 URL 的 body 内容，并且将在这个页面上找到的 URL 放到一个 slice 中。 Fetch(url string) (body string, urls []string, err error) } // Crawl 使用 fetcher 从某个 URL 开始递归的爬取页面，直到达到最大深度。 func Crawl(url string, depth int, fetcher Fetcher) { if depth \u0026lt;= 0 { wg.Done() return } if myset.have(url) { wg.Done() return } body, urls, err := fetcher.Fetch(url) myset.add(url) // 无论该网页是否找到，都做一次记录防止下次重复抓取 if err != nil { fmt.Println(err) wg.Done() return } fmt.Printf(\u0026quot;found: %s %q\\n\u0026quot;, url, body) for _, u := range urls { wg.Add(1) go Crawl(u, depth-1, fetcher) } wg.Done() return } func main() { myset = SafeUrlMap{set: make(map[string]int)} wg.Add(1) Crawl(\u0026quot;https://golang.org/\u0026quot;, 4, fetcher) wg.Wait() } // 带互斥锁的map，防止并行的写入 type SafeUrlMap struct { set map[string]int mux sync.Mutex } // url记录的查询方法 func (myset SafeUrlMap) add(url string) { myset.mux.Lock() // elem, ok = set[url] myset.set[url]++ myset.mux.Unlock() } // url记录的添加方法 func (myset SafeUrlMap) have(url string) bool { myset.mux.Lock() if myset.set[url] != 0 { defer myset.mux.Unlock() return true } return false } // fakeFetcher 是返回若干结果的 Fetcher。 type fakeFetcher map[string]*fakeResult type fakeResult struct { body string urls []string } func (f fakeFetcher) Fetch(url string) (string, []string, error) { if res, ok := f[url]; ok { return res.body, res.urls, nil } return \u0026quot;\u0026quot;, nil, fmt.Errorf(\u0026quot;not found: %s\u0026quot;, url) } // 已采集的Url清单,采集进程组 var ( myset SafeUrlMap wg sync.WaitGroup ) // fetcher 是填充后的 fakeFetcher。 var fetcher = fakeFetcher{ \u0026quot;https://golang.org/\u0026quot;: \u0026amp;fakeResult{ \u0026quot;The Go Programming Language\u0026quot;, []string{ \u0026quot;https://golang.org/pkg/\u0026quot;, \u0026quot;https://golang.org/cmd/\u0026quot;, }, }, \u0026quot;https://golang.org/pkg/\u0026quot;: \u0026amp;fakeResult{ \u0026quot;Packages\u0026quot;, []string{ \u0026quot;https://golang.org/\u0026quot;, \u0026quot;https://golang.org/cmd/\u0026quot;, \u0026quot;https://golang.org/pkg/fmt/\u0026quot;, \u0026quot;https://golang.org/pkg/os/\u0026quot;, }, }, \u0026quot;https://golang.org/pkg/fmt/\u0026quot;: \u0026amp;fakeResult{ \u0026quot;Package fmt\u0026quot;, []string{ \u0026quot;https://golang.org/\u0026quot;, \u0026quot;https://golang.org/pkg/\u0026quot;, }, }, \u0026quot;https://golang.org/pkg/os/\u0026quot;: \u0026amp;fakeResult{ \u0026quot;Package os\u0026quot;, []string{ \u0026quot;https://golang.org/\u0026quot;, \u0026quot;https://golang.org/pkg/\u0026quot;, }, }, }  ","id":8,"section":"posts","summary":"go指南练习 新手初学Go语言，看到这个go指南网站在线测试很方便做了几道练习后就在上面学习。 其中最后一页的测试： go指南练习:web爬虫 学了","tags":["go"],"title":"Go指南练习","uri":"https://liangkang233.github.io/2021/06/go%E6%8C%87%E5%8D%97%E7%BB%83%E4%B9%A0-web%E7%88%AC%E8%99%AB/","year":"2021"},{"content":"VScode是一款非常好用的代码编辑器，还拥有强大的在线扩展插件。甚至可以进行代码的debug，整理了下配置过程遇到的问题分享出来。 我使用的windows平台vscode版本为V1.56。\n通用配置 VS Code内置了对Node.js运行时的调试支持，可以调试JavaScript、TypeScript或JavaScript语言。\n要调试其他语言(包括PHP, Ruby, Go, c#， Python, C++， PowerShell等)时，在VS Code扩展中寻找调试器扩展，或者在顶级运行菜单中选择安装额外的调试器。\n确定安装可以编译调试的扩展或软件再进行以下步骤：\n右击工程文件夹使用VScode打开。 打开需要编译、运行的文件，点击顶部菜单-\u0026gt;运行-\u0026gt;添加配置\u0026hellip;选择需要debug的类型，之后根据语言及即可在 .vscode文件夹下生成launch.json文件。生成的json文件对整个文件夹和子文件夹生效。\n举例如何debug go 以go语言为例，路径切换至当前工程文件夹。首先安装调试软件推荐使用dlv，终端中输入\ngo get -u github.com/go-delve/delve/cmd/dlv # 未生成mod还得添加mod才能调试\tgo mod init yourProjectName  一切准备就绪后，点击上述步骤生成launch.json文件，此处会让你选择调试包还是附着到本地进程或远程服务器调试。 选择默认的调试package，这里打开生成的默认json\n{ // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \u0026quot;version\u0026quot;: \u0026quot;0.2.0\u0026quot;, \u0026quot;configurations\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;Launch Package\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;go\u0026quot;, \u0026quot;request\u0026quot;: \u0026quot;launch\u0026quot;, \u0026quot;mode\u0026quot;: \u0026quot;auto\u0026quot;, \u0026quot;program\u0026quot;: \u0026quot;${workspaceFolder}\u0026quot; } ] }  需要添加新的配置直接点击右下角即可，\u0026ldquo;name\u0026quot;的值为左标签页调试器的名字用于区分用。\n“type”语言类型设置为go，vs code 用于设定调试代码扩展类型。”mode“可以设置为 auto, debug, remote, test, exec 中的一个。\n”program“调试程序的路径（绝对路径），这里使用workspaceFolder说明对整个工作区目录文件进行调试。\n各配置变量的含义 其中有许多vscode定义的变量，这里列出常用的：\n ${workspaceFolder} - 在VS Code中打开的文件夹路径 ${workspaceFolderBasename} - 在VS Code中打开的文件夹的名称没有任何斜杠(/) ${file} - 当前打开的文件名 ${fileWorkspaceFolder} - 当前打开的文件的工作区文件夹 ${relativeFile} - 当前打开的文件名相对于workspaceFolder ${relativeFileDirname} - 当前打开的文件的目录名相对于workspaceFolder ${fileBasename} - 当前打开的文件的基名 ${fileBasenameNoExtension} - 当前打开的文件的基名没有文件扩展名 ${fileDirname} - 当前打开文件的目录名 ${fileExtname} - 当前打开的文件的扩展名 ${cwd} - 任务运行器启动时的当前工作目录 ${lineNumber} - 当前选中的行号在活动文件中 ${selectedText} - 活动文件中当前选定的文本 ${execPath} - 运行VS Code可执行文件的路径 ${defaultBuildTask} - 默认构建任务的名称 ${pathSeparator} - 操作系统用于分隔文件路径中的组件的字符 ${pathSeparator} - 在macOS或linux系统为/, 在Windows上为\\  关于debug C/C++ 该文件设置debug的各项配置根据语言的不同，设置也不尽相同。这里介绍c/c++的具体配置流程。  总结各文件作用 与其他语言类似的，debug的配置文件也是生成在.vscode文件夹中。 c/c++程序配置一般有三个文件：\n tasks.json（如何编译生成可执行程序） launch.json（调试设置） c_cpp_properties.json（编译器路径和vscode感知设置） 其中c_cpp_properties非常坑，由于我使用了自己写的头文件在c_cpp_properties.json的includePath项目配置各种路径类型都不生效，后面才看懂这个只是让vscode识别头文件该跳转的路径而已，真正要添加外部库或头文件的话要么放在系统默认库、头文件路径，要么在task.json中配置生成。  具体流程 c/c++代码需要先编译链接生成可执行程序（tasks.json），再使用gdb调试（launch.json），c_cpp_properties.json设置c/c++使用语言标准例如c++11等。注意：调试前确保系统环境已配置g++、gdb。验证方法：\n要检查您的 Mingw-w64 工具是否正确安装和可用，请打开新的命令提示并键入： g++ \u0026ndash;version gdb \u0026ndash;version 以此工程文件夹为例，main函数调用了lib文件夹下的stu_rw.h文件\n打开main.cpp文件，点击顶部菜单-\u0026gt;终端-\u0026gt;配置默认生成任务，选择使用g++生成活动文件。打开生成的task.json文件\n{ \u0026quot;version\u0026quot;: \u0026quot;2.0.0\u0026quot;, \u0026quot;tasks\u0026quot;: [ { \u0026quot;type\u0026quot;: \u0026quot;cppbuild\u0026quot;, \u0026quot;label\u0026quot;: \u0026quot;C/C++: g++.exe 生成活动文件\u0026quot;, \u0026quot;command\u0026quot;: \u0026quot;C:\\\\Program Files\\\\mingw-w64\\\\x86_64-8.1.0-posix-seh-rt_v6-rev0\\\\mingw64\\\\bin\\\\g++.exe\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;-g\u0026quot;, \u0026quot;-Wall\u0026quot;, //显示全部详细警告 \u0026quot;-std=c++11\u0026quot;, //支持C11 \u0026quot;${file}\u0026quot;,\t\u0026quot;-I\u0026quot;, \u0026quot;${workspaceFolder}\\\\lib\u0026quot;, \u0026quot;-o\u0026quot;, \u0026quot;${fileDirname}\\\\${fileBasenameNoExtension}.exe\u0026quot; ], \u0026quot;options\u0026quot;: { \u0026quot;cwd\u0026quot;: \u0026quot;${fileDirname}\u0026quot; }, \u0026quot;problemMatcher\u0026quot;: [ \u0026quot;$gcc\u0026quot; ], \u0026quot;group\u0026quot;: { \u0026quot;kind\u0026quot;: \u0026quot;build\u0026quot;, \u0026quot;isDefault\u0026quot;: true }, \u0026quot;detail\u0026quot;: \u0026quot;编译器: \\\u0026quot;C:\\\\Program Files\\\\mingw-w64\\\\x86_64-8.1.0-posix-seh-rt_v6-rev0\\\\mingw64\\\\bin\\\\g++.exe\\\u0026quot;\u0026quot; } ] }  其中args选项即为g++编译链接选项，如上所示我已经添加了\u0026rdquo;-I\u0026quot;相关参数添加头文件路径，c11标准。静态库链接等就放-o选项后，除最后一行配置文件每行都得加逗号。\n之后打开main.cpp点击顶部菜单-\u0026gt;终端-\u0026gt;运行生成任务，看是否生成成功。\n之后设定debug选项，点击顶部菜单-\u0026gt;运行-\u0026gt;添加配置，选择gdb、之后选g++生成默认配置。 下面展示配置的说明：\n{ // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \u0026quot;version\u0026quot;: \u0026quot;0.2.0\u0026quot;, \u0026quot;configurations\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;g++.exe - 生成和调试活动文件\u0026quot;,\t// 配置名称，将会在启动配置的下拉菜单中显示 \u0026quot;type\u0026quot;: \u0026quot;cppdbg\u0026quot;, \u0026quot;request\u0026quot;: \u0026quot;launch\u0026quot;,\t// 请求配置类型，可以为launch（启动）或attach（附加） \u0026quot;program\u0026quot;: \u0026quot;${fileDirname}\\\\${fileBasenameNoExtension}.exe\u0026quot;,\t// 将要进行调试的程序的路径 \u0026quot;args\u0026quot;: [],\t// 程序调试时传递给程序的命令行参数，一般设为空即可 \u0026quot;stopAtEntry\u0026quot;: false, \u0026quot;cwd\u0026quot;: \u0026quot;${fileDirname}\u0026quot;, \u0026quot;environment\u0026quot;: [], \u0026quot;externalConsole\u0026quot;: false, \u0026quot;MIMode\u0026quot;: \u0026quot;gdb\u0026quot;, \u0026quot;miDebuggerPath\u0026quot;: \u0026quot;C:\\\\Program Files\\\\mingw-w64\\\\x86_64-8.1.0-posix-seh-rt_v6-rev0\\\\mingw64\\\\bin\\\\gdb.exe\u0026quot;, \u0026quot;setupCommands\u0026quot;: [ { \u0026quot;description\u0026quot;: \u0026quot;为 gdb 启用整齐打印\u0026quot;, \u0026quot;text\u0026quot;: \u0026quot;-enable-pretty-printing\u0026quot;, \u0026quot;ignoreFailures\u0026quot;: true } ], \u0026quot;preLaunchTask\u0026quot;: \u0026quot;C/C++: g++.exe 生成活动文件\u0026quot; } ] }  如果您想要对 C/C++扩展进行更多控制，c_cpp_properties.json将配置如编译器的路径，include路径、C++标准（默认值为 C++17）等等。\n通过命令终端（Ctrl+Shift+P）输入\u0026gt;c/c++，有两个选项一个是直接配置json一个是通过UI界面配置。\n这里的C/C++ 配置UI页面，基本保持默认即可。注意这里的配置编辑器是给vscode和扩展使用的，不影响task.json来配置真正生成可执行程序的过程。\n","id":9,"section":"posts","summary":"VScode是一款非常好用的代码编辑器，还拥有强大的在线扩展插件。甚至可以进行代码的debug，整理了下配置过程遇到的问题分享出来。 我使用的","tags":[""],"title":"Vscode配置debug","uri":"https://liangkang233.github.io/2021/06/vsode%E9%85%8D%E7%BD%AEdebug/","year":"2021"},{"content":"背景 我目前需要解决一个需求，将一个c工程中的特定数据转发到VUE前端框架上做界面展示，且该框架已经有后端为flask框架。\n所以得考虑如何将c工程中的数据发送到python中。容易知道，进程间通信的方式有管道、信号量、消息队列、共享内存、套接字等。为了简易实现上述功能和尽量不影响他们两边原先进程的功能，使用套接字发送封装的数据做http请求给flask后端，这样来实现数据转发。\nHTTP（超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。具体区别这篇博客讲的很详细。总而言之http连接=以http协议为通信协议的tcp连接，http协议可以由tcp协议封装报文而来，现在要解决的就是c的套接字如何封装成符合http协议的get/post请求。\n参考案例 最开始找了网上很多案例，tcp套接字细节此处不赘述。http请求就是其tcp传输附上对应http请求的报文，但是实际测试不对，没有相应返回。猜想到可能测试环境不同封装格式也要改变，所以使用wireshark抓包软件抓了个具体的数据包来分析。 使用的get、post请求的html页面\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;GET and POST\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action = \u0026quot;http://localhost:5000\u0026quot; method = \u0026quot;get\u0026quot;\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Name\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input type =\u0026quot;text\u0026quot; name =\u0026quot;username\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Password\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input type =\u0026quot;password\u0026quot; name =\u0026quot;password\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input type = \u0026quot;get submit\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;form action = \u0026quot;http://localhost:5000\u0026quot; method = \u0026quot;post\u0026quot;\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Name\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input type =\u0026quot;text\u0026quot; name =\u0026quot;username\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Password\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input type =\u0026quot;password\u0026quot; name =\u0026quot;password\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input type = \u0026quot;post submit\u0026quot;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  后端flask接收代码\nfrom flask import Flask, request app = Flask(__name__) @app.route('/', methods=['GET']) def index(): username = request.args.get('username') password = request.args.get('password') if username == \u0026quot;xugaoxiang\u0026quot; and password == \u0026quot;xugaoxiang\u0026quot;: return f\u0026quot;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;Welcome {username}\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026quot; else: return f\u0026quot;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;Welcome!\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026quot; @app.route('/', methods=['POST']) def index(): username = request.form['username'] password = request.form['password'] if username == \u0026quot;xugaoxiang\u0026quot; and password == \u0026quot;xugaoxiang\u0026quot;: return f\u0026quot;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;Welcome {username}\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026quot; else: return f\u0026quot;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;Welcome!\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026quot; if __name__ == '__main__': app.run(debug=True)  测试案例取自此教程，贴出教程源码链接：https://github.com/xugaoxiang/FlaskTutorial 其抓包结果如下所示： 只需要关注http数据包中的tcp报文内容即可。 具体实现 注：为了解决大小端和数据位数不统一的问题，我是将所有数据转为字符串来发送。如果想要发送json等数据格式同样用抓包看下具体如何封装即可，此处简易的实现先不考虑那些功能。 有了上面的数据样本，进行下面c代码的封装转发。使用环境不同，部分函数可能有所变化。这里只展示基础模板。 真正通用的是下面这段补齐信令的函数\nvoid addget(const char* str1) //补齐get信令数据 { strcat(str1, \u0026quot;Host: 127.0.0.1\\r\\n\u0026quot;);//cname记录不影响连接，此处不做修改 strcat(str1, \u0026quot;Content-Type: text/html\\r\\n\\r\\n\u0026quot;); } void addpost(char* str1, const char* data) //补齐post信令数据 { char postlength[128]; sprintf(postlength, \u0026quot;%d\\r\\n\u0026quot;, strlen(data + 1)); strcat(str1, \u0026quot;Host: 127.0.0.1\\r\\n\u0026quot;);//cname记录不影响连接，此处不做修改 strcat(str1, \u0026quot;Content-Type: application/x-www-form-urlencoded\\r\\n\u0026quot;); strcat(str1, \u0026quot;Content-Length: \u0026quot;); strcat(str1, postlength); strcat(str1, \u0026quot;\\r\\n\\r\\n\u0026quot;); strcat(str1, data + 1);\t} /* 调用方式 //data即为传输而来的数据 case get_test:{\t// 封装成http的get请求 strcpy(str1, \u0026quot;GET /getsometing?\u0026quot;); strcat(str1, data + 1); strcat(str1, \u0026quot; HTTP/1.1\\r\\n\u0026quot;); addget(str1); break; } case post_test:{\t// 封装成http的post请求 strcpy(str1, \u0026quot;POST /postsometing HTTP/1.1\\r\\n\u0026quot;); addpost(str1, data); break;\t} */  请求代码模板 只讨论http请求方面内容，展示基础的tcp套接字绑定及封装http请求流程\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;winsock2.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;assert.h\u0026gt; #define PORT 5000\t// 设定发送端口 #define BUFSIZE 1024 #define DATASIZE 2000 enum send_flask_type { start=1, accomplish, get_test, post_test }; // 实现函数，flaskip为http请求的ip地址 此处为环回地址127.0.0.1 data为传输数据(例如type=start) send_type设定传输方式 int HandleFlask(const char* flaskip, const char* data, int send_type) { int i, sockfd_flask; fd_set t_set1; struct timeval timeset; struct sockaddr_in flaskaddr; char str1[2 * DATASIZE], buf[BUFSIZE]; //* 创建flask连接套接字 *// if ((sockfd_flask = socket(AF_INET, SOCK_STREAM, 0)) \u0026lt; 0 ) { printf(\u0026quot;创建网络连接失败,本线程即将终止!\\n\u0026quot;); return -1; } flaskaddr.sin_family = AF_INET; flaskaddr.sin_addr.s_addr = inet_addr(flaskip); flaskaddr.sin_port = htons(PORT); memset(\u0026amp;flaskaddr.sin_zero, 0, 8); if (connect(sockfd_flask, (struct sockaddr *)\u0026amp;flaskaddr, sizeof(flaskaddr)) \u0026lt; 0){ printf(\u0026quot;连接到flask服务器失败!\\n\u0026quot;); return -1; } // printf(\u0026quot;连接Flask服务器成功\\n\u0026quot;); switch(send_type) { case get_test:{\t/* 封装成http的get请求 */ strcpy(str1, \u0026quot;GET /getsometing?\u0026quot;); // if(SplitStr(data + 1, str1) \u0026lt; 0) { //将data中的tpye数字类型转成字符串并添加至str1 // printf(\u0026quot;需要转发的报文格式有误\\n\u0026quot;); // return -1; // } strcat(str1, data + 1); strcat(str1, \u0026quot; HTTP/1.1\\r\\n\u0026quot;); addget(str1); break; } case post_test:{\t/* 封装成http的post请求 */ strcpy(str1, \u0026quot;POST /postsometing HTTP/1.1\\r\\n\u0026quot;); addpost(str1, data); break;\t} default:{ printf(\u0026quot;接收到无效格式，舍弃\\n\u0026quot;); return 0; } } i = send(sockfd_flask, str1, strlen(str1), 0); if (i \u0026lt; 0) { // printf(\u0026quot;发送失败！错误代码是%d，错误信息是'%s'\\n\u0026quot;,errno, strerror(errno)); printf(\u0026quot;发送数据给flask失败！错误代码是%d\\n\u0026quot;, WSAGetLastError());//windows获取erron closesocket(sockfd_flask); return -1; } else { // printf(\u0026quot;消息发送至flask成功，共发送了%d个字节！send_type=%d \\n\u0026quot;, i, send_type); } // python安装插件eventlet后，外部http访问后flask不会立即关闭套接字 // (即falsk return后不会发送空的tcp报文)， // 所以此修改为不考虑复杂场景只接收一次flask的http返回数据后就关闭套接字 FD_ZERO(\u0026amp;t_set1); FD_SET(sockfd_flask, \u0026amp;t_set1); timeset.tv_sec= 0; timeset.tv_usec= 100000; //扫描堵塞时间100ms i= select(sockfd_flask +1, \u0026amp;t_set1, NULL, NULL, \u0026amp;timeset); if (i == 0) { // printf(\u0026quot;长时间未接收到flask http响应，跳过\\n\u0026quot;); // continue; // break; } else if (i \u0026lt; 0) { printf(\u0026quot;在读取flask数据报文时SELECT检测到异常，该异常导致线程终止！\\n\u0026quot;); closesocket(sockfd_flask); return -1; } else { memset(buf, 0, sizeof(buf) ); i = recv(sockfd_flask, buf, sizeof(buf), 0); if (i \u0026lt;= 0) { closesocket(sockfd_flask); if (i == 0) { // printf(\u0026quot;与flask通信的http套接字关闭\\n\u0026quot;); return 0; } else { printf(\u0026quot;接收flask数据报出现错误！错误代码是%d\\n\u0026quot;, WSAGetLastError()); //windows获取erron return -1; } } else { //对http返回值进行处理 // printf(\u0026quot;flask返回值%s\\n\u0026quot;, buf); // continue; // break; } } closesocket(sockfd_flask); return 0; }  flask接收示例 # flask后端测试用 @app.route('/getsometing', methods=['GET']) def gettest(): type = request.args.get('type') src = request.args.get('src') dst = request.args.get('dst') print(f\u0026quot;get data: type={type},src={src},dst={dst}\u0026quot;) return f\u0026quot;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;get return: type={type},src={src},dst={dst}\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026quot; @app.route('/postsometing', methods=['POST']) def posttest(): type = request.form['type'] src = request.form['src'] dst = request.form['dst'] print(f\u0026quot;post data: type={type},src={src},dst={dst}\u0026quot;) return f\u0026quot;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;post return: type={type},src={src},dst={dst}\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026quot;  如果数据量比较大可以这样写\n@app.route('/getsometing', methods=['GET']) def gettest(): get_data=request.args.to_dict() type = get_data['type'] cur_time=time.strftime(\u0026quot;%Y-%m-%d %H:%M:%S\u0026quot;, time.localtime()) if type == 'Start' : #自己定义的发送数据的type pass elif type == 'Accomplish' : pass elif type == 'change' : pass else : print (\u0026quot;接收到无效数据，将其丢弃\u0026quot;) with open(\u0026quot;log.txt\u0026quot;, \u0026quot;a+\u0026quot;) as f: f.write('\\n# ' + cur_time + ' ---------- get error：\\n' + json.dumps(get_data)) return \u0026quot;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt; Flask access invalid data \u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026quot; return \u0026quot;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt; data access \u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026quot; @app.route('/postsometing', methods=['POST']) def posttest(): post_data = request.form.to_dict() print (post_data) type = post_data['type'] cur_time=time.strftime(\u0026quot;%Y-%m-%d %H:%M:%S\u0026quot;, time.localtime()) if type == \u0026quot;change\u0026quot;: pass else : print (\u0026quot;接收到无效数据，将其丢弃\u0026quot;) with open(\u0026quot;log.txt\u0026quot;, \u0026quot;a+\u0026quot;) as f: f.write('\\n# ' + cur_time + ' ---------- post error：\\n' + json.dumps(post_data)) return \u0026quot;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt; Flask access invalid data \u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026quot; return \u0026quot;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt; data access \u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026quot;  ","id":10,"section":"posts","summary":"背景 我目前需要解决一个需求，将一个c工程中的特定数据转发到VUE前端框架上做界面展示，且该框架已经有后端为flask框架。 所以得考虑如何将c","tags":["C/C++"],"title":"C语言实现的http请求","uri":"https://liangkang233.github.io/2021/06/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0http%E8%AF%B7%E6%B1%82/","year":"2021"},{"content":"思路 python的特性支持快速开发实用小程序的能力，能让你做事效率大幅度提高。特别是在c++数据测试中，检验一个程序的可靠性需要大量数据进行测试可靠性。虽然c++也有随机函数等方法但是不方便移植更改，用Python编写数据生成器是再合适不过的了。接下来进行举例说明：下面的代码直接在python3终端中运行，生成一个长度在4 ~9之间， 恰好包含一个大写字母， 其他字符为小写字母的特殊串。\n\u0026gt;\u0026gt;\u0026gt; from random import* \u0026gt;\u0026gt;\u0026gt; from string import* \u0026gt;\u0026gt;\u0026gt; L = randint(4, 9) \u0026gt;\u0026gt;\u0026gt; s =''.join([choice(ascii_lowercase) for i in range(L)]) \u0026gt;\u0026gt;\u0026gt; p = randint(0, len(s)) \u0026gt;\u0026gt;\u0026gt; s[:p] + choice(ascii_uppercase) + s[p:] ' bdsqVgke'  列表解析Clist comprehension) 是一种构造列表的简单方法。range(5) 生成列表[0,1,2,3,4]。这条语句就是 “对于列表[0,1,2,3,4]中的每个数i调用一次 choice(lowercase)，把结果拼成一个列表” 。接下来用join函数把列表里的字符串连接起来。 .join(L)的作用是把字符串列表L中的各个字符串拼接起来。 最后随机出小写字符出现的位置p, 然后插入到大写字母串中。s[a:b]代表列表或者字符串的第a个元素到第b-1 个元素。a和b都可以省略，a默认为0, b默认为列表长度。L2 = L[:］的作用是创建一个和L 一样的数组。 由于Python 的所有值都是引用类型的， 因此L2=L只是把L中保存的引用拷贝（浅拷贝）到了L2，这点需要小心。例如下面的代码，求其地址id可以分析出来。\n\u0026gt;\u0026gt;\u0026gt; a,b=1,2 \u0026gt;\u0026gt;\u0026gt; a= [1,3,7] \u0026gt;\u0026gt;\u0026gt; b=[1,3,7] \u0026gt;\u0026gt;\u0026gt; c,d=a,a[:] \u0026gt;\u0026gt;\u0026gt; id (a), id (b), id (c), id (d) (12598008, 12517288, 12598008, 12517208)  计算 30!可以采用如下写法:\n\u0026gt;\u0026gt;\u0026gt; from functools import* \u0026gt;\u0026gt;\u0026gt; reduce(lambda x,y: x*y, range(1,31)) 265252859812191058636308480000000L  简单实现 类似的东西还有很多。 使用Python后， 能大大缩短编写数据生成器、对拍器、 “猜想验证器” 等小程序的时间，这里我打算把python生成的数据全部转为字符数据存入文本中(转字符数据就不用考虑int位数 浮点数精度等问题)。c++再读数据存入容器进行原本函数的测试。\npython生成数据代码 接下来的代码为进行测试写入文件的代码，作为参考：\n# !/usr/bin/env python3 # coding: utf-8 from random import * from string import * def create_element0(lines, a = 4, b = 7): elements = [] for i in range(lines): # ascii_lowercase在string中定义，为所有小写字符的列表 # choice(seq): 返回列表、元组或字符串seq的随机项str。（可重复） L = randint(a, b) s =''.join([choice(ascii_lowercase) for i in range(L)]) p = randint(0, len(s)) element = s[:p] + choice(ascii_uppercase) + s[p:] + '\\n' elements.append(element) return elements def create_element1(lines): elements = [] for i in range(lines): # sample: 不重复的取列表中i个元素，并返回这些元素组成的列表 # 不可像choice中列表添加for in，因为其返回的是列表 # 要生成m个不重复i元素列表得在外面加循环 username = ''.join(sample(ascii_letters + digits, 5)) password = randint(10000,99999) element= str(username) + \u0026quot;,\u0026quot; + str(password) + '\\n' elements.append(element) return elements def create_element2(lines): elements = [] allNum = list(range(-10000, 10000)) NumLen = len(allNum) #在allNum中抽取Len个不重复数字,最后依照题意排序，旋转。共lines组 for i in range(lines): s = [] num = randint(1, 256) for j in range(num) : index = randint(j, NumLen - 1) s.append(allNum[index]) # 把用过的元素到前面,以防再次选中 allNum[index], allNum[i] = allNum[i], allNum[index] # 模拟target是否存在，有1/36的几率必定不存在 suiji = randint(0,35) if suiji == 35: target = 10001 else : target = s[randint(0, num-1)] #排序取出的不重复数组并旋转 s.sort() k = randint(0, num-1) if k != 0 : s = list(reversed(s[0:k])) + list(reversed(s[k:num])) s.reverse() element = ' '.join([str(s[i]) for i in range(num)]) + '\\n' elements.append(element) elements.append(str(target) + '\\n') print(f\u0026quot;i = {i},\\t k = {k}, \\ttarget = {target}\u0026quot;) return elements  C++读取文件代码 C++中各种流头文件说明 iostream处理控制台IO； fstream处理命名文件IO； stringstream完成内存string的IO。 类fstream和stringstream都是继承在类iostream的。 输入类都继承自istream，输出类都继承自ostream。 string流：sstream头文件定义了三个类型来支持内存IO， 这些类型可以向string写入数据，从string读取数据，就像string是一个IO流一样。 将所有行数据打印出： 该代码仅为读取数据并载入容器中作为模板使用，若要加入判断正确等功能可以根据实际情况添加\n// 导入文本至容器，将每一行的数据以空格为间隔输入一个字符容器，将所有行的数据输入 int main() { string temp; ifstream myfile(\u0026quot;./date.txt\u0026quot;); if( !myfile ) { cout \u0026lt;\u0026lt; \u0026quot;open file fail!\u0026quot; \u0026lt;\u0026lt; endl; return -1; } vector\u0026lt;string\u0026gt; res; while (getline(myfile, temp)) {\t//默认停止符\\n stringstream slices(temp); string slice; while (slices \u0026gt;\u0026gt; slice) {\t// 类似cin输入，将每行排除不可显字符 空格等字符输入容器，直到接收回车为止 res.push_back(slice); // stoi(int), stol(long), stof(float), stod(double) } // for( auto r : res) //\tcout \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; res.clear(); } myfile.close(); return 0; }  实际测试案例 上述测试确定无问题后，开始实际做python数据导入c++中做测试： 其中c++代码为leetcode题目搜索旋转排序数组 python生成数据函数即为上述代码的create_element2用于测试判断c++代码是否正确 接下来是c++的读取文件并进行调用。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;sstream\u0026gt; #include \u0026lt;fstream\u0026gt; using namespace std; // 自己写的跟官方的思路差不多，官方答案不用先找到最大临界值再二分 直接进行判断二分 // 下面为官方答案，注意 边界 等于 问题 class Solution { public: int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int n = (int)nums.size(); if (!n) return -1; else if (n == 1) return nums[0] == target ? 0 : -1; int l = 0, r = n - 1; while (l \u0026lt;= r) { int mid = (l + r) / 2; if (nums[mid] == target) return mid; // target判断是否为mid if (nums[0] \u0026lt;= nums[mid]) { // 说明0到mid是升序 if (nums[0] \u0026lt;= target \u0026amp;\u0026amp; target \u0026lt; nums[mid]) // target在该升序中 r = mid - 1; else l = mid + 1; } else { // 说明mid到n-1是升序 if (nums[mid] \u0026lt; target \u0026amp;\u0026amp; target \u0026lt;= nums[n - 1]) // target在该升序中 l = mid + 1; else r = mid - 1; } } return -1; } }; // 导入文本至容器测试，将每一行的数据以空格为间隔输入一个字符容器，将所有行的数据输入 int main() { string temp; ifstream myfile(\u0026quot;./date.txt\u0026quot;); if( !myfile ) { cout \u0026lt;\u0026lt; \u0026quot;open file fail!\u0026quot; \u0026lt;\u0026lt; endl; return -1; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ress; vector\u0026lt;int\u0026gt; res; vector\u0026lt;int\u0026gt; targets; while (getline(myfile, temp)) {\t//默认停止符\\n stringstream slices(temp); string slice; while (slices \u0026gt;\u0026gt; slice) {\t// 类似cin输入，将每行排除不可显字符 空格等字符输入容器，直到接收回车为止 res.push_back(stoi(slice)); // stoi(int), stol(long), stof(float), stod(double) } getline(myfile, temp); targets.push_back(stoi(temp)); // for( auto rio : res) // cout \u0026lt;\u0026lt; rio \u0026lt;\u0026lt; endl; ress.push_back(res); res.clear(); } myfile.close(); Solution su; for (int i = 0; i \u0026lt; ress.size(); i++) { int ans = su.search(ress[i], targets[i]); cout \u0026lt;\u0026lt; targets[i] \u0026lt;\u0026lt; ' ' \u0026lt;\u0026lt; ans \u0026lt;\u0026lt;endl; } return 0; }  ","id":11,"section":"posts","summary":"思路 python的特性支持快速开发实用小程序的能力，能让你做事效率大幅度提高。特别是在c++数据测试中，检验一个程序的可靠性需要大量数据进行","tags":["python","C/C++"],"title":"Python随机数据生成","uri":"https://liangkang233.github.io/2021/05/python%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90/","year":"2021"},{"content":"本人习惯使用onenote记录一些问题和做记录，最近发现开启本地http代理服务器后onenote无法同步，但是我代理配置是无误的。经过查询发现这个是uwp应用的特性：\nUWP 是微软在 Windows 10 中引入的新概念，由于所有 UWP 应用均运行在被称为 App Container 的虚拟沙箱环境中，其安全性及纯净度远胜于传统的 EXE 应用。但 App Container 机制同时也阻止了网络流量发送到本机（即 loopback）， 使大部分网络抓包调试工具无法对 UWP 应用进行流量分析。同样的，该机制也阻止了 UWP 应用访问 localhost，即使你在系统设置中启用了代理，也无法令 UWP 应用访问本地代理服务器。\n所以只要设置uwp应用可以访问本地代理服务器就能解决问题了。\n解决方法： 参考官方给的解决方案 要解决此问题，您需要使用PowerShell命令将有关应用添加到 Windows 10 回路豁免列表。 将带有\u0026quot;Microsoft.MinecraftUWP_8wekyb3d8bbwe\u0026quot;的包名的应用程序添加到循环回路豁免列表中。 要查找包名，您可以使用以下powershell命令：\nGet-AppxPackage #列出所有uwp应用程序。 Get-AppxPackage | Select-String -Pattern \u0026quot;Minecraft\u0026quot; #列出所有名字中含有“Minecraft”的应用程序。 CheckNetIsolation LoopbackExempt -d -n=\u0026quot;Microsoft.MinecraftUWP_8wekyb3d8bbwe\u0026quot; # 使用程序名字从豁免列表中剔除该程序 CheckNetIsolation LoopbackExempt -d -p=\u0026quot;sid编号\u0026quot; # 使用程序sid从豁免列表中剔除该程序 CheckNetIsolation LoopbackExempt -s #展示豁免列表 CheckNetIsolation LoopbackExempt -c #清除豁免列表  法1 查询注册表sid 举例：\nGet-AppxPackage | Select-String -Pattern \u0026quot;onenote\u0026quot;\t#查找onenote包名称 #查询到onenote 包名为 Microsoft.Office.OneNote_16001.13801.20202.0_x64__8wekyb3d8bbwe CheckNetIsolation LoopbackExempt -a -n=\u0026quot;Microsoft.Office.OneNote_16001.13801.20202.0_x64__8wekyb3d8bbwe\u0026quot; #添加至豁免列表 CheckNetIsolation LoopbackExempt -d -n=\u0026quot;Microsoft.Office.OneNote_16001.13801.20202.0_x64__8wekyb3d8bbwe\u0026quot; #从豁免列表中移除  法2 注册表查询程序包名 win+r 输入regedit，打开注册表编辑器，地址栏粘贴 HKEY_CURRENT_USER\\Software\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\CurrentVersion\\AppContainer\\Mappings，里面的DisplayName值就是应用名称，查询对应程序的sid类似S-1-15-2-3445883232-1224167743-206467785-1580939083-2750001491-3097792036-3019341970形式\nCheckNetIsolation.exe loopbackexempt -a -p=UWP的SID CheckNetIsolation.exe loopbackexempt -d -p=UWP的SID #举例：豁免onenote走代理 CheckNetIsolation.exe loopbackexempt -a -p=S-1-15-2-3445883232-1224167743-206467785-1580939083-2750001491-3097792036-3019341970  onenote问题 可惜的是，法1对MinecraftUWP有效，对onenote失效。可能是其包名不对，该包名指向的是office套件中的onenote。打印如下的豁免表可知，法二生成的豁免表是生效的 法2生成\n列出环回免除的 AppContainer [1] ----------------------------------------------------------------- 名称: microsoft.office.onenote_8wekyb3d8bbwe SID: S-1-15-2-3445883232-1224167743-206467785-1580939083-2750001491-3097792036-3019341970 [2] ----------------------------------------------------------------- 名称: AppContainer NOT FOUND SID: S-1-15-2-3624051433-2125758914-1423191267-1740899205-1073925389-3782572162-737981194-4043415302-551583165-304772019-4009825106 [3] ----------------------------------------------------------------- 名称: 001 SID: S-1-15-2-3624051433-2125758914-1423191267-1740899205-1073925389-3782572162-737981194-4256926629-1688279915-2739229046-3928706915  法1生成\n列出环回免除的 AppContainer [1] ----------------------------------------------------------------- 名称: AppContainer NOT FOUND SID: S-1-15-2-883788003-1897955942-3642183005-638760255-2249287259-3707616651-3249579104 [2] ----------------------------------------------------------------- 名称: AppContainer NOT FOUND SID: S-1-15-2-3624051433-2125758914-1423191267-1740899205-1073925389-3782572162-737981194-4043415302-551583165-304772019-4009825106 [3] ----------------------------------------------------------------- 名称: 001 SID: S-1-15-2-3624051433-2125758914-1423191267-1740899205-1073925389-3782572162-737981194-4256926629-1688279915-2739229046-3928706915  ","id":12,"section":"posts","summary":"本人习惯使用onenote记录一些问题和做记录，最近发现开启本地http代理服务器后onenote无法同步，但是我代理配置是无误的。经过查询","tags":["小问题"],"title":"uwp应用代理","uri":"https://liangkang233.github.io/2021/04/uwp%E5%BA%94%E7%94%A8%E4%BB%A3%E7%90%86/","year":"2021"},{"content":"功能 之前想获得一段机器配音时，总是一句一句粘贴在翻译软件上读取，非常麻烦。 后来知道百度AI提供了免费的语音合成api，所以简单分享下使用方法。\n使用说明 百度智能云语音识别\n  首先打开上述网址点击立即开始注册或登录账号\n  创建一个应用并按照你的需求注册，当然不只是语音识别还有其他类似人脸识别图像处理等接口，但是大部分是要收费的。具体其他业务可以看看官方指南  这些我们可以不管，只需要注册语音识别应用，文本转语音业务包含在其中。注册好可以如下图领取免费额度。   最后配置完成后，下载python的sdk来安装,使用python setup.py install\n  其他组件 所有组件github地址: 百度AI python sdk地址. 其它功能也可类似调用接口实现，这里只是简单使用语音识别的文本语音转换功能。\n文本转语音测试 参考了官方的测试案例编写了下面的代码，有兴趣的可以试试其他api的调用，此代码python2 3皆可使用。\n# coding: utf-8 # 逐行读入source/test.txt文件，并创建audio1.mp3 audio2.mp3 audio3.mp3存入source文件夹中 ...... import sys import json IS_PY3 = sys.version_info.major == 3 if IS_PY3: from urllib.request import urlopen from urllib.request import Request from urllib.error import URLError from urllib.parse import urlencode from urllib.parse import quote_plus else: import urllib2 from urllib import quote_plus from urllib2 import urlopen from urllib2 import Request from urllib2 import URLError from urllib import urlencode API_KEY = '此处替换为你应用的API_KEY ' SECRET_KEY = '此处替换为你应用的SECRET_KEY' TEXT = \u0026quot;欢迎使用百度语音合成。\u0026quot; # 发音人选择，默认为度小美 # 基础音库：0为度小美，1为度小宇，3为度逍遥，4为度丫丫， # 精品音库：5为度小娇，103为度米朵，106为度博文，110为度小童，111为度小萌 PER = 3 # 语速，取值0-15，默认为5中语速 SPD = 6 # 音调，取值0-15，默认为5中语调 PIT = 5 # 音量，取值0-9，默认为5中音量 VOL = 7 # 下载的文件格式, 3：mp3(default) 4： pcm-16k 5： pcm-8k 6. wav AUE = 3 FORMATS = {3: \u0026quot;.mp3\u0026quot;, 4: \u0026quot;.pcm\u0026quot;, 5: \u0026quot;.pcm\u0026quot;, 6: \u0026quot;.wav\u0026quot;} FORMAT = FORMATS[AUE] CUID = \u0026quot;123456PYTHON\u0026quot; TTS_URL = 'http://tsn.baidu.com/text2audio' class DemoError(Exception): pass \u0026quot;\u0026quot;\u0026quot; TOKEN start \u0026quot;\u0026quot;\u0026quot; TOKEN_URL = 'http://openapi.baidu.com/oauth/2.0/token' SCOPE = 'audio_tts_post' # 有此scope表示有tts能力，没有请在网页里勾选 def fetch_token(): print(\u0026quot;fetch token begin\u0026quot;) params = {'grant_type': 'client_credentials', 'client_id': API_KEY, 'client_secret': SECRET_KEY} post_data = urlencode(params) if (IS_PY3): post_data = post_data.encode('utf-8') req = Request(TOKEN_URL, post_data) try: f = urlopen(req, timeout=5) result_str = f.read() except URLError as err: print('token http response http code : ' + str(err.code)) result_str = err.read() if (IS_PY3): result_str = result_str.decode() print(result_str) result = json.loads(result_str) print(result) if ('access_token' in result.keys() and 'scope' in result.keys()): if not SCOPE in result['scope'].split(' '): raise DemoError('scope is not correct') print('SUCCESS WITH TOKEN: %s ; EXPIRES IN SECONDS: %s' % (result['access_token'], result['expires_in'])) return result['access_token'] else: raise DemoError('MAYBE API_KEY or SECRET_KEY not correct: access_token or scope not found in token response') \u0026quot;\u0026quot;\u0026quot; TOKEN end \u0026quot;\u0026quot;\u0026quot; def tts(str, id): # tex = quote_plus(TEXT) tex = quote_plus(text[i]) # 此处TEXT需要两次urlencode print(tex) params = {'tok': token, 'tex': tex, 'per': PER, 'spd': SPD, 'pit': PIT, 'vol': VOL, 'aue': AUE, 'cuid': CUID, 'lan': 'zh', 'ctp': 1} # lan ctp 固定参数 data = urlencode(params) print('test on Web Browser' + TTS_URL + '?' + data) req = Request(TTS_URL, data.encode('utf-8')) has_error = False try: f = urlopen(req) result_str = f.read() headers = dict((name.lower(), value) for name, value in f.headers.items()) has_error = ('content-type' not in headers.keys() or headers['content-type'].find('audio/') \u0026lt; 0) except URLError as err: print('asr http response http code : ' + str(err.code)) result_str = err.read() has_error = True save_file = \u0026quot;error.txt\u0026quot; if has_error else \u0026quot;./source/result\u0026quot; + id + FORMAT #三目运算符 with open(save_file, 'wb') as of: of.write(result_str) if has_error: if (IS_PY3): result_str = str(result_str, 'utf-8') print(\u0026quot;tts api error:\u0026quot; + result_str) print(\u0026quot;result saved as :\u0026quot; + save_file) if __name__ == '__main__': token = fetch_token() text = [] file = open(\u0026quot;./source/test.txt\u0026quot;, 'r', encoding='UTF-8') while True: lines = file.readlines(100000) if not lines: break for line in lines: text.append(line) for i in range(len(text)): tts(text[i], str(i+1))  ","id":13,"section":"posts","summary":"功能 之前想获得一段机器配音时，总是一句一句粘贴在翻译软件上读取，非常麻烦。 后来知道百度AI提供了免费的语音合成api，所以简单分享下使用方法","tags":["python"],"title":"批量语音转文字","uri":"https://liangkang233.github.io/2021/04/%E6%89%B9%E9%87%8F%E8%AF%AD%E9%9F%B3%E8%BD%AC%E5%AD%97%E7%AC%A6/","year":"2021"},{"content":"功能 由于刚好有需求要更改配置文件参数，想到python简单易用的特点，所以边学边做了这个程序帮助修改参数。该程序功能为读取一个二进制文本其中的参数按照指定格式修改。\n参考教程 文件读写教程. 正则表达式教程. python的很多基础都是在廖雪峰老师这学的，写的很详细不错，所以后面的分析就不详细说了。\n源码 #!/usr/bin/python3 # coding: utf-8 speed = int(input(\u0026quot;Please enter the adjustment speed: \u0026quot;)) #修改test.config文件 with open('test.config', 'r', encoding='utf-8') as o_config : lines = o_config.readlines() # readlines返回每行字符串组成的list flen=len(lines) for i in range(flen): if lines[i].startswith(\u0026quot;SIMULATION-TIME\u0026quot;) : config_value = lines[i].split(' ') value = int( config_value[1][0:-2:1] ) # 用切片删去S和回车转成值 value = int(3600 / speed) lines[i] = config_value[0] + ' ' + str(value) + 'S\\n' break else : continue with open('test.config','w', encoding='utf-8') as new_config : new_config.writelines(lines) #修改test.nodes文件 with open('test.nodes', 'r', encoding='utf-8') as o_config : lines = o_config.readlines() # readlines返回每行字符串组成的list flen=len(lines) for i in range(flen): if lines[i] == '\\n' : break node_value = lines[i].split(' ', 2) if node_value[1] == '0' : continue else : value = int( node_value[1][0: -1:1] ) value = int( value / speed ) lines[i] = node_value[0] + ' ' + str(value) + 'S ' + node_value[2] with open('test.nodes','w', encoding='utf-8') as new_nodes : new_nodes.writelines(lines) print(\u0026quot;Modified to complete\u0026quot;)  代码分析  python修改文本暂时没找到直接更改办法，上述代码都是先读取文本复制到内存中的列表，修改后再将列表写入文件。 修改test.config文件代码，使用readlines返回每行字符串组成的list。当然也可以用readline和while读取每一行来进行操作。 使用startswith对每行行首判断寻找关键字符串类型，之后使用split空格分开为字符串列表后用切片提取出值对应的字符串。 例如下图中config文件会读取到lines[8]这行有待寻找关键字，用split生成list[\u0026lsquo;SIMULATION-TIME\u0026rsquo;, \u0026lsquo;3600S\\n\u0026rsquo;], 进行切片操作[1:-2:1]得到字符串'3600' (回车\\n也需要切片去除)，这样转化成int型处理完再转为字符串填充回原来列表中即可。  之后类似的对test.nodes进行操作!\n  此处，由于其配置文件规则简单由空格区分，所以处理起来只需要split和列表切片，若是复杂的字符串数据还是得用上面教程中的正则表达式来处理。 此外，如果需要更改参数精度更好的案例这里也提供一份\n#!/usr/bin/python3 #coding: utf-8 #修改 1.nodes文件 speed = 100 with open('1.nodes', 'r', encoding='utf-8') as o_config : lines = o_config.readlines() # readlines返回每行字符串组成的list flen=len(lines) for i in range(flen): if lines[i] == '\\n' : break node_value = lines[i].split(' ', 5) valuex = round( float( node_value[2][1: -1:1]) / speed,14 ) valuey = round( float( node_value[3][1: -1:1]) / speed,14 ) valuez = round( float( node_value[4][1: -1:1]) / speed,14 ) # lines[i] = node_value[0] + ' ' + node_value[1] + ' (' + \\ # str(valuex) + ', ' + str(valuey) + ', ' + str(valuez) + ') ' + node_value[5] lines[i] = node_value[0] + ' ' + node_value[1] + ' (' + \\ '%.014f'%valuex + ', ' + '%.014f'%valuey + ', ' + '%.014f'%valuez + ') ' + node_value[5] with open('1.nodes','w', encoding='utf-8') as new_nodes : new_nodes.writelines(lines) print(\u0026quot;Modified to complete\u0026quot;)  ","id":14,"section":"posts","summary":"功能 由于刚好有需求要更改配置文件参数，想到python简单易用的特点，所以边学边做了这个程序帮助修改参数。该程序功能为读取一个二进制文本其中","tags":["python"],"title":"Pthon读写文件","uri":"https://liangkang233.github.io/2021/03/python%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/","year":"2021"},{"content":"hello world 测试 老生常谈的hello world，在此之前的原blog帖子会归档本地草稿\n各测试项目文件 draft: true,\ntag: blog test\n  rich-content\n  emoji-support\n  markdown-syntax\n  placeholder-text\n  video test  .aspect-ratio { position: relative; width: 100%; height: 0; padding-bottom: 75%; } .aspect-ratio iframe { position: absolute; width: 100%; height: 100%; left: 0; top: 0; }   \n  ","id":15,"section":"posts","summary":"hello world 测试 老生常谈的hello world，在此之前的原blog帖子会归档本地草稿 各测试项目文件 draft: true, tag: blog test rich-content emoji-support markdown-syntax placeholder-text video test .aspect-ratio { position: relative; width: 100%; height: 0; padding-bottom: 75%; } .aspect-ratio iframe","tags":["blog test"],"title":"Hello World","uri":"https://liangkang233.github.io/2020/12/hello-world/","year":"2020"}],"tags":[{"title":"blog test","uri":"https://liangkang233.github.io/tags/blog-test/"},{"title":"C/C++","uri":"https://liangkang233.github.io/tags/c/c++/"},{"title":"go","uri":"https://liangkang233.github.io/tags/go/"},{"title":"python","uri":"https://liangkang233.github.io/tags/python/"},{"title":"仿真","uri":"https://liangkang233.github.io/tags/%E4%BB%BF%E7%9C%9F/"},{"title":"小问题","uri":"https://liangkang233.github.io/tags/%E5%B0%8F%E9%97%AE%E9%A2%98/"}]}